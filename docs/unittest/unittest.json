{"name":"unittest","qualifiedName":"unittest/unittest","comment":"<p>Support for writing Dart unit tests.</p>\n<p>For information on installing and importing this library, see the\n<a href=\"http://pub.dartlang.org/packages/unittest\">unittest package on pub.dartlang.org</a>.</p>\n<p><strong>See also:</strong>\n<a href=\"http://www.dartlang.org/articles/dart-unit-tests/\">Unit Testing with Dart</a></p>\n<h2>Concepts</h2><ul><li>\n<p><strong>Tests</strong>: Tests are specified via the top-level function <a>unittest/unittest.test</a>, they can be\n   organized together using <a>unittest/unittest.group</a>.</p></li><li>\n<p><strong>Checks</strong>: Test expectations can be specified via expect</p></li><li>\n<p><strong>Matchers</strong>: expect assertions are written declaratively using the\n   Matcher class.</p></li><li>\n<p><strong>Configuration</strong>: The framework can be adapted by setting\n   <a>unittest/unittest.unittestConfiguration</a> with a <a>unittest/unittest.Configuration</a>. See the other libraries\n   in the <code>unittest</code> package for alternative implementations of\n   <a>unittest/unittest.Configuration</a> including <code>compact_vm_config.dart</code>, <code>html_config.dart</code>\n   and <code>html_enhanced_config.dart</code>.</p></li></ul>\n<h2>Examples</h2>\n<p>A trivial test:</p>\n<pre><code>import 'package:unittest/unittest.dart';\nmain() {\n  test('this is a test', () {\n    int x = 2 + 3;\n    expect(x, equals(5));\n  });\n}\n</code></pre>\n<p>Multiple tests:</p>\n<pre><code>import 'package:unittest/unittest.dart';\nmain() {\n  test('this is a test', () {\n    int x = 2 + 3;\n    expect(x, equals(5));\n  });\n  test('this is another test', () {\n    int x = 2 + 3;\n    expect(x, equals(5));\n  });\n}\n</code></pre>\n<p>Multiple tests, grouped by category:</p>\n<pre><code>import 'package:unittest/unittest.dart';\nmain() {\n  group('group A', () {\n    test('test A.1', () {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    });\n    test('test A.2', () {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    });\n  });\n  group('group B', () {\n    test('this B.1', () {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    });\n  });\n}\n</code></pre>\n<p>Asynchronous tests: if callbacks expect between 0 and 6 positional\narguments, <a>unittest/unittest.expectAsync</a> will wrap a function into a new callback and will\nnot consider the test complete until that callback is run. A count argument\ncan be provided to specify the number of times the callback should be called\n(the default is 1).</p>\n<pre><code>import 'dart:async';\nimport 'package:unittest/unittest.dart';\nvoid main() {\n  test('callback is executed once', () {\n    // wrap the callback of an asynchronous call with [expectAsync] if\n    // the callback takes 0 arguments...\n    var timer = Timer.run(expectAsync(() {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    }));\n  });\n\n  test('callback is executed twice', () {\n    var callback = expectAsync(() {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    }, count: 2); // &lt;-- we can indicate multiplicity to [expectAsync]\n    Timer.run(callback);\n    Timer.run(callback);\n  });\n}\n</code></pre>\n<p>There may be times when the number of times a callback should be called is\nnon-deterministic. In this case a dummy callback can be created with\nexpectAsync((){}) and this can be called from the real callback when it is\nfinally complete.</p>\n<p>A variation on this is <a>unittest/unittest.expectAsyncUntil</a>, which takes a callback as the\nfirst parameter and a predicate function as the second parameter. After each\ntime the callback is called, the predicate function will be called. If it\nreturns <code>false</code> the test will still be considered incomplete.</p>\n<p>Test functions can return <a>unittest/dart-async.Future</a>s, which provide another way of doing\nasynchronous tests. The test framework will handle exceptions thrown by\nthe Future, and will advance to the next test when the Future is complete.</p>\n<pre><code>import 'dart:async';\nimport 'package:unittest/unittest.dart';\nvoid main() {\n  test('test that time has passed', () {\n    var duration = const Duration(milliseconds: 200);\n    var time = new DateTime.now();\n\n    return new Future.delayed(duration).then((_) {\n      var delta = new DateTime.now().difference(time);\n\n      expect(delta, greaterThanOrEqualTo(duration));\n    });\n  });\n}\n</code></pre>","variables":{"isNonNegative":{"name":"isNonNegative","qualifiedName":"matcher/matcher.isNonNegative","comment":"<p>A matcher which matches if the match argument is zero or positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"matcher/matcher.isNegative","comment":"<p>A matcher which matches if the match argument is negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNonPositive":{"name":"isNonPositive","qualifiedName":"matcher/matcher.isNonPositive","comment":"<p>A matcher which matches if the match argument is zero or negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isPositive":{"name":"isPositive","qualifiedName":"matcher/matcher.isPositive","comment":"<p>A matcher which matches if the match argument is positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNonZero":{"name":"isNonZero","qualifiedName":"matcher/matcher.isNonZero","comment":"<p>A matcher which matches if the match argument is non-zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isZero":{"name":"isZero","qualifiedName":"matcher/matcher.isZero","comment":"<p>A matcher which matches if the match argument is zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"completes":{"name":"completes","qualifiedName":"matcher/matcher.completes","comment":"<p>Matches a <a>dart-async.Future</a> that completes successfully with a value. Note that this\ncreates an asynchronous expectation. The call to <code>expect()</code> that includes\nthis will return immediately and execution will continue. Later, when the\nfuture completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>matcher/matcher.throws</a> and\n<a>matcher/matcher.throwsA</a>.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"wrapAsync":{"name":"wrapAsync","qualifiedName":"matcher/matcher.wrapAsync","comment":"<p>Some matchers, like those for Futures and exception testing,\ncan fail in asynchronous sections, and throw exceptions.\nA user of this library will typically want to catch and handle\nsuch exceptions. The <a>matcher/matcher.wrapAsync</a> property is a function that\ncan wrap callbacks used by these Matchers so that they can be\nused safely. For example, the unittest library will set this\nto be <code>expectAsync</code>. By default this is an identity function.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.Function","inner":[]}],"annotations":[]},"isList":{"name":"isList","qualifiedName":"matcher/matcher.isList","comment":"<p>A matcher for List types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isMap":{"name":"isMap","qualifiedName":"matcher/matcher.isMap","comment":"<p>A matcher for Map types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsCyclicInitializationError":{"name":"throwsCyclicInitializationError","qualifiedName":"matcher/matcher.throwsCyclicInitializationError","comment":"<p>A matcher for functions that throw CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isCyclicInitializationError":{"name":"isCyclicInitializationError","qualifiedName":"matcher/matcher.isCyclicInitializationError","comment":"<p>A matcher for CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsAbstractClassInstantiationError":{"name":"throwsAbstractClassInstantiationError","qualifiedName":"matcher/matcher.throwsAbstractClassInstantiationError","comment":"<p>A matcher for functions that throw AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isAbstractClassInstantiationError":{"name":"isAbstractClassInstantiationError","qualifiedName":"matcher/matcher.isAbstractClassInstantiationError","comment":"<p>A matcher for AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsConcurrentModificationError":{"name":"throwsConcurrentModificationError","qualifiedName":"matcher/matcher.throwsConcurrentModificationError","comment":"<p>A matcher for functions that throw ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isConcurrentModificationError":{"name":"isConcurrentModificationError","qualifiedName":"matcher/matcher.isConcurrentModificationError","comment":"<p>A matcher for ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsNullThrownError":{"name":"throwsNullThrownError","qualifiedName":"matcher/matcher.throwsNullThrownError","comment":"<p>A matcher for functions that throw NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNullThrownError":{"name":"isNullThrownError","qualifiedName":"matcher/matcher.isNullThrownError","comment":"<p>A matcher for NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsFallThroughError":{"name":"throwsFallThroughError","qualifiedName":"matcher/matcher.throwsFallThroughError","comment":"<p>A matcher for functions that throw FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isFallThroughError":{"name":"isFallThroughError","qualifiedName":"matcher/matcher.isFallThroughError","comment":"<p>A matcher for FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsStateError":{"name":"throwsStateError","qualifiedName":"matcher/matcher.throwsStateError","comment":"<p>A matcher for functions that throw StateError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isStateError":{"name":"isStateError","qualifiedName":"matcher/matcher.isStateError","comment":"<p>A matcher for StateErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsUnsupportedError":{"name":"throwsUnsupportedError","qualifiedName":"matcher/matcher.throwsUnsupportedError","comment":"<p>A matcher for functions that throw UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isUnsupportedError":{"name":"isUnsupportedError","qualifiedName":"matcher/matcher.isUnsupportedError","comment":"<p>A matcher for UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsUnimplementedError":{"name":"throwsUnimplementedError","qualifiedName":"matcher/matcher.throwsUnimplementedError","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isUnimplementedError":{"name":"isUnimplementedError","qualifiedName":"matcher/matcher.isUnimplementedError","comment":"<p>A matcher for UnimplementedErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsNoSuchMethodError":{"name":"throwsNoSuchMethodError","qualifiedName":"matcher/matcher.throwsNoSuchMethodError","comment":"<p>A matcher for functions that throw NoSuchMethodError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNoSuchMethodError":{"name":"isNoSuchMethodError","qualifiedName":"matcher/matcher.isNoSuchMethodError","comment":"<p>A matcher for NoSuchMethodErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsRangeError":{"name":"throwsRangeError","qualifiedName":"matcher/matcher.throwsRangeError","comment":"<p>A matcher for functions that throw RangeError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isRangeError":{"name":"isRangeError","qualifiedName":"matcher/matcher.isRangeError","comment":"<p>A matcher for RangeErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsArgumentError":{"name":"throwsArgumentError","qualifiedName":"matcher/matcher.throwsArgumentError","comment":"<p>A matcher for functions that throw ArgumentError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isArgumentError":{"name":"isArgumentError","qualifiedName":"matcher/matcher.isArgumentError","comment":"<p>A matcher for ArgumentErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsException":{"name":"throwsException","qualifiedName":"matcher/matcher.throwsException","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isException":{"name":"isException","qualifiedName":"matcher/matcher.isException","comment":"<p>A matcher for Exceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"throwsFormatException":{"name":"throwsFormatException","qualifiedName":"matcher/matcher.throwsFormatException","comment":"<p>A matcher for functions that throw FormatException.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isFormatException":{"name":"isFormatException","qualifiedName":"matcher/matcher.isFormatException","comment":"<p>A matcher for FormatExceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"returnsNormally":{"name":"returnsNormally","qualifiedName":"matcher/matcher.returnsNormally","comment":"<p>A matcher that matches a function call against no exception.\nThe function will be called once. Any exceptions will be silently swallowed.\nThe value passed to expect() should be a reference to the function.\nNote that the function cannot take arguments; to handle this\na wrapper will have to be created.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throws":{"name":"throws","qualifiedName":"matcher/matcher.throws","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"anything":{"name":"anything","qualifiedName":"matcher/matcher.anything","comment":"<p>A matcher that matches any value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isFalse":{"name":"isFalse","qualifiedName":"matcher/matcher.isFalse","comment":"<p>A matcher that matches anything except the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isTrue":{"name":"isTrue","qualifiedName":"matcher/matcher.isTrue","comment":"<p>A matcher that matches the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNotNull":{"name":"isNotNull","qualifiedName":"matcher/matcher.isNotNull","comment":"<p>A matcher that matches any non-null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNull":{"name":"isNull","qualifiedName":"matcher/matcher.isNull","comment":"<p>A matcher that matches any null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"matcher/matcher.isEmpty","comment":"<p>Returns a matcher that matches empty strings, maps or iterables\n(including collections).</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"filterStacks":{"name":"filterStacks","qualifiedName":"unittest/unittest.filterStacks","comment":"<p>A flag that controls whether we try to filter out irrelevant frames from\nthe stack trace. Requires formatStacks to be set.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"formatStacks":{"name":"formatStacks","qualifiedName":"unittest/unittest.formatStacks","comment":"<p>A flag that controls whether we hide unittest and core library details in\nexception stacks.</p>\n<p>Useful to disable when debugging unittest or matcher customizations.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"ERROR":{"name":"ERROR","qualifiedName":"unittest/unittest.ERROR","comment":"<p>Result string for an test case with an error.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"FAIL":{"name":"FAIL","qualifiedName":"unittest/unittest.FAIL","comment":"<p>Result string for a failing test case.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"PASS":{"name":"PASS","qualifiedName":"unittest/unittest.PASS","comment":"<p>Result string for a passing test case.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"BREATH_INTERVAL":{"name":"BREATH_INTERVAL","qualifiedName":"unittest/unittest.BREATH_INTERVAL","comment":"<p>Interval (in msecs) after which synchronous tests will insert an async\ndelay to allow DOM or other updates.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"testCases":{"name":"testCases","qualifiedName":"unittest/unittest.testCases","comment":"<p>Tests executed in this suite.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"unittest/unittest.TestCase","inner":[]}]}],"annotations":[]},"groupSep":{"name":"groupSep","qualifiedName":"unittest/unittest.groupSep","comment":"<p>Separator used between group names and test names.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"functions":{"setters":{"unittestConfiguration=":{"name":"unittestConfiguration=","qualifiedName":"unittest/unittest.unittestConfiguration=","comment":"<p>Sets the <a>unittest/unittest.Configuration</a> used by the unittest library.</p>\n<p>Throws a <a>dart-core.StateError</a> if there is an existing, incompatible value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.Configuration","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"getters":{"currentTestCase":{"name":"currentTestCase","qualifiedName":"unittest/unittest.currentTestCase","comment":"<p><a>unittest/unittest.TestCase</a> currently being executed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.TestCase","inner":[]}],"parameters":{},"annotations":[]},"unittestConfiguration":{"name":"unittestConfiguration","qualifiedName":"unittest/unittest.unittestConfiguration","comment":"<p><a>unittest/unittest.Configuration</a> used by the unittest library. Note that if a\nconfiguration has not been set, calling this getter will create\na default configuration.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Configuration","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"matches":{"name":"matches","qualifiedName":"unittest/unittest.matches","comment":"<p>Returns a matcher that matches if the match argument is a string and\nmatches the regular expression given by <a>unittest/unittest.matches.re</a>. <a>unittest/unittest.matches.re</a> can be a RegExp\ninstance or a string; in the latter case it will be used to create\na RegExp instance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"re":{"name":"re","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"stringContainsInOrder":{"name":"stringContainsInOrder","qualifiedName":"unittest/unittest.stringContainsInOrder","comment":"<p>Returns a matcher that matches if the match argument is a string and\ncontains a given list of <a>unittest/unittest.stringContainsInOrder.substrings</a> in relative order.</p>\n<p>For example, <code>stringContainsInOrder([\"a\", \"e\", \"i\", \"o\", \"u\"])</code> will match\n\"abcdefghijklmnopqrstuvwxyz\".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"substrings":{"name":"substrings","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"endsWith":{"name":"endsWith","qualifiedName":"unittest/unittest.endsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nends with <a>unittest/unittest.endsWith.suffixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"suffixString":{"name":"suffixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"startsWith":{"name":"startsWith","qualifiedName":"unittest/unittest.startsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nstarts with <a>unittest/unittest.startsWith.prefixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"prefixString":{"name":"prefixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"collapseWhitespace":{"name":"collapseWhitespace","qualifiedName":"unittest/unittest.collapseWhitespace","comment":"<p>Utility function to collapse whitespace runs to single spaces\nand strip leading/trailing whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"equalsIgnoringWhitespace":{"name":"equalsIgnoringWhitespace","qualifiedName":"unittest/unittest.equalsIgnoringWhitespace","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to value when compared with all runs of whitespace\ncollapsed to single spaces and leading and trailing whitespace removed.</p>\n<p>For example, <code>equalsIgnoringCase(\"hello world\")</code> will match\n\"hello   world\", \"  hello world\" and \"hello world  \".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"equalsIgnoringCase":{"name":"equalsIgnoringCase","qualifiedName":"unittest/unittest.equalsIgnoringCase","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to <a>unittest/unittest.equalsIgnoringCase.value</a> when compared case-insensitively.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"anyOf":{"name":"anyOf","qualifiedName":"unittest/unittest.anyOf","comment":"<p>Matches if any of the given matchers evaluate to true. The\narguments can be a set of matchers as separate parameters\n(up to 7), or a List of matchers.</p>\n<p>The matchers are evaluated from left to right using short-circuit\nevaluation, so evaluation stops as soon as a matcher returns true.</p>\n<p>Any argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"allOf":{"name":"allOf","qualifiedName":"unittest/unittest.allOf","comment":"<p>This returns a matcher that matches if all of the matchers passed as\narguments (up to 7) match. Instead of passing the matchers separately\nthey can be passed as a single List argument.\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"isNot":{"name":"isNot","qualifiedName":"unittest/unittest.isNot","comment":"<p>This returns a matcher that inverts <a>unittest/unittest.isNot.matcher</a> to its logical negation.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"inClosedOpenRange":{"name":"inClosedOpenRange","qualifiedName":"unittest/unittest.inClosedOpenRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to a <a>unittest/unittest.inClosedOpenRange.low</a> and less than <a>unittest/unittest.inClosedOpenRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"inOpenClosedRange":{"name":"inOpenClosedRange","qualifiedName":"unittest/unittest.inOpenClosedRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>unittest/unittest.inOpenClosedRange.low</a> and less than or equal to <a>unittest/unittest.inOpenClosedRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"inExclusiveRange":{"name":"inExclusiveRange","qualifiedName":"unittest/unittest.inExclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>unittest/unittest.inExclusiveRange.low</a> and less than <a>unittest/unittest.inExclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"inInclusiveRange":{"name":"inInclusiveRange","qualifiedName":"unittest/unittest.inInclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to <a>unittest/unittest.inInclusiveRange.low</a> and less than or equal to <a>unittest/unittest.inInclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"closeTo":{"name":"closeTo","qualifiedName":"unittest/unittest.closeTo","comment":"<p>Returns a matcher which matches if the match argument is within <a>unittest/unittest.closeTo.delta</a>\nof some <a>unittest/unittest.closeTo.value</a>; i.e. if the match argument is greater than\nthan or equal <a>unittest/unittest.closeTo.value</a>-<a>unittest/unittest.closeTo.delta</a> and less than or equal to <a>unittest/unittest.closeTo.value</a>+<a>unittest/unittest.closeTo.delta</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"delta":{"name":"delta","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"lessThanOrEqualTo":{"name":"lessThanOrEqualTo","qualifiedName":"unittest/unittest.lessThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is less\nthan or equal to the given <a>unittest/unittest.lessThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"lessThan":{"name":"lessThan","qualifiedName":"unittest/unittest.lessThan","comment":"<p>Returns a matcher which matches if the match argument is less\nthan the given <a>unittest/unittest.lessThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"greaterThanOrEqualTo":{"name":"greaterThanOrEqualTo","qualifiedName":"unittest/unittest.greaterThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to the given <a>unittest/unittest.greaterThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"greaterThan":{"name":"greaterThan","qualifiedName":"unittest/unittest.greaterThan","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan the given <a>unittest/unittest.greaterThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"containsPair":{"name":"containsPair","qualifiedName":"unittest/unittest.containsPair","comment":"<p>Returns a matcher which matches maps containing the key-value pair\nwith <a>unittest/unittest.containsPair.key</a> => <a>unittest/unittest.containsPair.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"containsValue":{"name":"containsValue","qualifiedName":"unittest/unittest.containsValue","comment":"<p>Returns a matcher which matches maps containing the given <a>unittest/unittest.containsValue.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"pairwiseCompare":{"name":"pairwiseCompare","qualifiedName":"unittest/unittest.pairwiseCompare","comment":"<p>A pairwise matcher for iterable. You can pass an arbitrary <a>unittest/unittest.pairwiseCompare.comparator</a>\nfunction that takes an expected and actual argument which will be applied\nto each pair in order. <a>unittest/unittest.pairwiseCompare.description</a>  should be a meaningful name for\nthe comparator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":"null","annotations":[]},"comparator":{"name":"comparator","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"unorderedMatches":{"name":"unorderedMatches","qualifiedName":"unittest/unittest.unorderedMatches","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s whose elements match the matchers\nin <a>unittest/unittest.unorderedMatches.expected</a>, but not necessarily in the same order.</p>\n<p> Note that this is <code>O(n^2)</code> and so should only be used on small objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"unorderedEquals":{"name":"unorderedEquals","qualifiedName":"unittest/unittest.unorderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>unittest/unittest.unorderedEquals.expected</a>, but not necessarily in\nthe same order. Note that this is O(n^2) so should only be used on\nsmall objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"orderedEquals":{"name":"orderedEquals","qualifiedName":"unittest/unittest.orderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>unittest/unittest.orderedEquals.expected</a>, and in the same order.\nThis is equivalent to equals but does not recurse.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"anyElement":{"name":"anyElement","qualifiedName":"unittest/unittest.anyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which at least one\nelement matches the given <a>unittest/unittest.anyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"everyElement":{"name":"everyElement","qualifiedName":"unittest/unittest.everyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which all elements\nmatch the given <a>unittest/unittest.everyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"completion":{"name":"completion","qualifiedName":"unittest/unittest.completion","comment":"<p>Matches a <a>unittest/dart-async.Future</a> that completes succesfully with a value that matches\n<a>unittest/unittest.completion.matcher</a>. Note that this creates an asynchronous expectation. The call to\n<code>expect()</code> that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>unittest/matcher.throws</a> and\n<a>unittest/unittest.throwsA</a>.</p>\n<p><a>unittest/unittest.completion.id</a> is an optional tag that can be used to identify the completion matcher\nin error messages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"StringConstant(\"\")","annotations":[]}},"annotations":[]},"configureExpectFormatter":{"name":"configureExpectFormatter","qualifiedName":"unittest/unittest.configureExpectFormatter","comment":"<p>Changes or resets to default the failure message formatter for expect().\n<a>unittest/unittest.configureExpectFormatter.formatter</a> is a reference to the new formatter; if this is omitted or\nnull then the failure formatter is reset to the default. The new\nformatter is returned; this allows custom expect handlers to easily\nget a reference to the default formatter.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher-interfaces.ErrorFormatter","inner":[]}],"parameters":{"formatter":{"name":"formatter","optional":true,"named":false,"default":true,"type":[{"outer":"matcher-interfaces.ErrorFormatter","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getOrCreateExpectFailureHandler":{"name":"getOrCreateExpectFailureHandler","qualifiedName":"unittest/unittest.getOrCreateExpectFailureHandler","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"parameters":{},"annotations":[]},"configureExpectFailureHandler":{"name":"configureExpectFailureHandler","qualifiedName":"unittest/unittest.configureExpectFailureHandler","comment":"<p>Changes or resets to the default the failure handler for expect()\n<a>unittest/unittest.configureExpectFailureHandler.handler</a> is a reference to the new handler; if this is omitted\nor null then the failure handler is reset to the default, which\nthrows <a>unittest/unittest.TestFailure</a>s on <a>unittest/unittest.expect</a> assertion failures.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"handler":{"name":"handler","optional":true,"named":false,"default":true,"type":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"wrapMatcher":{"name":"wrapMatcher","qualifiedName":"unittest/unittest.wrapMatcher","comment":"<p>Takes an argument and returns an equivalent matcher.\nIf the argument is already a matcher this does nothing,\nelse if the argument is a function, it generates a predicate\nfunction matcher, else it generates an equals matcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"x":{"name":"x","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"fail":{"name":"fail","qualifiedName":"unittest/unittest.fail","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"expect":{"name":"expect","qualifiedName":"unittest/unittest.expect","comment":"<p>This is the main assertion function. It asserts that <a>unittest/unittest.expect.actual</a>\nmatches the <a>unittest/unittest.expect.matcher</a>. <a>unittest/unittest.expect.reason</a> is optional and is typically not\nsupplied, as a reason is generated from the matcher; if <a>unittest/unittest.expect.reason</a>\nis included it is appended to the reason generated by the matcher.</p>\n<p><a>unittest/unittest.expect.matcher</a> can be a value in which case it will be wrapped in an\n<a>unittest/unittest.equals</a> matcher.</p>\n<p>If the assertion fails, then the default behavior is to throw a\n<a>unittest/unittest.TestFailure</a>, but this behavior can be changed by calling\n<a>unittest/unittest.configureExpectFailureHandler</a> and providing an alternative handler that\nimplements the IFailureHandler interface. It is also possible to\npass a <a>unittest/unittest.expect.failureHandler</a> to <a>unittest/unittest.expect</a> as a final parameter for fine-\ngrained control.</p>\n<p>In some cases extra diagnostic info can be produced on failure (for\nexample, stack traces on mismatched exceptions). To enable these,\n<a>unittest/unittest.expect.verbose</a> should be specified as true;</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"reason":{"name":"reason","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"value":"null","annotations":[]},"verbose":{"name":"verbose","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"addStateInfo":{"name":"addStateInfo","qualifiedName":"unittest/unittest.addStateInfo","comment":"<p>Useful utility for nesting match states.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":"null","annotations":[]},"values":{"name":"values","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"predicate":{"name":"predicate","qualifiedName":"unittest/unittest.predicate","comment":"<p>Returns a matcher that uses an arbitrary function that returns\ntrue or false for the actual value. For example:</p>\n<pre><code>expect(v, predicate((x) =&gt; ((x % 2) == 0), \"is even\"))\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"StringConstant(\"satisfies function\")","annotations":[]}},"annotations":[]},"isIn":{"name":"isIn","qualifiedName":"unittest/unittest.isIn","comment":"<p>Returns a matcher that matches if the match argument is in\nthe expected value. This is the converse of <a>unittest/unittest.contains</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"unittest/unittest.contains","comment":"<p>Returns a matcher that matches if the match argument contains\nthe expected value. For <a>dart-core.String</a>s this means substring matching;\nfor <a>dart-core.Map</a>s it means the map has the key, and for <a>dart-core.Iterable</a>s\n(including <a>dart-core.Iterable</a>s) it means the iterable has a matching\nelement. In the case of iterables, <a>unittest/unittest.contains.expected</a> can itself be a\nmatcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"hasLength":{"name":"hasLength","qualifiedName":"unittest/unittest.hasLength","comment":"<p>Returns a matcher that matches if an object has a length property\nthat matches <a>unittest/unittest.hasLength.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"throwsA":{"name":"throwsA","qualifiedName":"unittest/unittest.throwsA","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>unittest/dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>\n<p>In both cases, when an exception is thrown, this will test that the exception\nobject matches <a>unittest/unittest.throwsA.matcher</a>. If <a>unittest/unittest.throwsA.matcher</a> is not an instance of <a>unittest/unittest.Matcher</a>, it\nwill implicitly be treated as <code>equals(matcher)</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"equals":{"name":"equals","qualifiedName":"unittest/unittest.equals","comment":"<p>Returns a matcher that matches if the value is structurally equal to\n<a>unittest/unittest.equals.expected</a>.</p>\n<p>If <a>unittest/unittest.equals.expected</a> is a <a>unittest/unittest.Matcher</a>, then it matches using that. Otherwise it tests\nfor equality using <code>==</code> on the expected value.</p>\n<p>For <a>dart-core.Iterable</a>s and <a>dart-core.Map</a>s, this will recursively match the elements. To\nhandle cyclic structures a recursion depth <a>unittest/unittest.equals.limit</a> can be provided. The\ndefault limit is 100.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"limit":{"name":"limit","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"100","annotations":[]}},"annotations":[]},"same":{"name":"same","qualifiedName":"unittest/unittest.same","comment":"<p>Returns a matches that matches if the value is the same instance\nas <a>unittest/unittest.same.expected</a>, using <a>dart-core.identical</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"disableTest":{"name":"disableTest","qualifiedName":"unittest/unittest.disableTest","comment":"<p>Disable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"enableTest":{"name":"enableTest","qualifiedName":"unittest/unittest.enableTest","comment":"<p>Enable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"setSoloTest":{"name":"setSoloTest","qualifiedName":"unittest/unittest.setSoloTest","comment":"<p>Select a solo test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"ensureInitialized":{"name":"ensureInitialized","qualifiedName":"unittest/unittest.ensureInitialized","comment":"<p>Lazily initializes the test library if not already initialized.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"registerException":{"name":"registerException","qualifiedName":"unittest/unittest.registerException","comment":"<p>Registers that an exception was caught for the current test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"trace":{"name":"trace","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"guardAsync":{"name":"guardAsync","qualifiedName":"unittest/unittest.guardAsync","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>unittest/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"tryBody":{"name":"tryBody","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"runTests":{"name":"runTests","qualifiedName":"unittest/unittest.runTests","comment":"<p>Runs all queued tests, one at a time.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"filterTests":{"name":"filterTests","qualifiedName":"unittest/unittest.filterTests","comment":"<p>Filter the tests. <a>unittest/unittest.filterTests.testFilter</a> can be a <a>dart-core.RegExp</a>, a <a>dart-core.String</a> or a\npredicate function. This is different to enabling/disabling tests\nin that it removes the tests completely.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testFilter":{"name":"testFilter","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"handleExternalError":{"name":"handleExternalError","qualifiedName":"unittest/unittest.handleExternalError","comment":"<p>Handle errors that happen outside the tests.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"stack":{"name":"stack","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"tearDown":{"name":"tearDown","qualifiedName":"unittest/unittest.tearDown","comment":"<p>Register a <a>unittest/unittest.tearDown</a> function for a test <a>unittest/unittest.group</a>. This function will\nbe called after each test in the group is run. Note that if groups\nare nested only the most locally scoped <a>unittest/unittest.tearDown.teardownTest</a> function will be run.\n<a>unittest/unittest.setUp</a> and <a>unittest/unittest.tearDown</a> should be called within the <a>unittest/unittest.group</a> before any\ncalls to <a>unittest/unittest.test</a>. The <a>unittest/unittest.tearDown.teardownTest</a> function can be asynchronous; in this\ncase it must return a <a>unittest/dart-async.Future</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"teardownTest":{"name":"teardownTest","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"setUp":{"name":"setUp","qualifiedName":"unittest/unittest.setUp","comment":"<p>Register a <a>unittest/unittest.setUp</a> function for a test <a>unittest/unittest.group</a>. This function will\nbe called before each test in the group is run.\n<a>unittest/unittest.setUp</a> and <a>unittest/unittest.tearDown</a> should be called within the <a>unittest/unittest.group</a> before any\ncalls to <a>unittest/unittest.test</a>. The <a>unittest/unittest.setUp.setupTest</a> function can be asynchronous; in this\ncase it must return a <a>unittest/dart-async.Future</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"setupTest":{"name":"setupTest","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"solo_group":{"name":"solo_group","qualifiedName":"unittest/unittest.solo_group","comment":"<p>Like <a>unittest/unittest.solo_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"skip_group":{"name":"skip_group","qualifiedName":"unittest/unittest.skip_group","comment":"<p>Like <a>unittest/unittest.skip_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"group":{"name":"group","qualifiedName":"unittest/unittest.group","comment":"<p>Creates a new named group of tests. Calls to group() or test() within the\nbody of the function passed to this will inherit this group's description.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"protectAsync2":{"name":"protectAsync2","qualifiedName":"unittest/unittest.protectAsync2","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>unittest/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"protectAsync1":{"name":"protectAsync1","qualifiedName":"unittest/unittest.protectAsync1","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>unittest/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"protectAsync0":{"name":"protectAsync0","qualifiedName":"unittest/unittest.protectAsync0","comment":"<p><em>Deprecated</em></p>\n<p>All tests are now run an isolated <a>unittest/dart-async.Zone</a>.</p>\n<p>You can safely remove calls to this method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil2":{"name":"expectAsyncUntil2","qualifiedName":"unittest/unittest.expectAsyncUntil2","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>unittest/unittest.expectAsyncUntil</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil1":{"name":"expectAsyncUntil1","qualifiedName":"unittest/unittest.expectAsyncUntil1","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>unittest/unittest.expectAsyncUntil</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil0":{"name":"expectAsyncUntil0","qualifiedName":"unittest/unittest.expectAsyncUntil0","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>unittest/unittest.expectAsyncUntil</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsyncUntil":{"name":"expectAsyncUntil","qualifiedName":"unittest/unittest.expectAsyncUntil","comment":"<p>Indicate that <a>unittest/unittest.expectAsyncUntil.callback</a> is expected to be called until <a>unittest/unittest.expectAsyncUntil.isDone</a> returns\ntrue. The unittest framework check <a>unittest/unittest.expectAsyncUntil.isDone</a> after each callback and only\nwhen it returns true will it continue with the following test. Using\n<a>unittest/unittest.expectAsyncUntil</a> will also ensure that errors that occur within\n<a>unittest/unittest.expectAsyncUntil.callback</a> are tracked and reported. <a>unittest/unittest.expectAsyncUntil.callback</a> should take 0 positional\narguments (named arguments are not supported). <a>unittest/unittest.expectAsyncUntil.id</a> can be used to\nidentify the callback in error messages (for example if it is called\nafter the test case is complete).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"expectAsync2":{"name":"expectAsync2","qualifiedName":"unittest/unittest.expectAsync2","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>unittest/unittest.expectAsync</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsync1":{"name":"expectAsync1","qualifiedName":"unittest/unittest.expectAsync1","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>unittest/unittest.expectAsync</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsync0":{"name":"expectAsync0","qualifiedName":"unittest/unittest.expectAsync0","comment":"<p><em>Deprecated</em></p>\n<p>Use <a>unittest/unittest.expectAsync</a> instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[{"name":"dart-core.Deprecated","parameters":["next release"]}]},"expectAsync":{"name":"expectAsync","qualifiedName":"unittest/unittest.expectAsync","comment":"<p>Indicate that <a>unittest/unittest.expectAsync.callback</a> is expected to be called a <a>unittest/unittest.expectAsync.count</a> number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified <a>unittest/unittest.expectAsync.count</a> times before it continues with the following test.  Using\n<a>unittest/unittest.expectAsync</a> will also ensure that errors that occur within <a>unittest/unittest.expectAsync.callback</a> are\ntracked and reported. <a>unittest/unittest.expectAsync.callback</a> should take 0 positional arguments (named\narguments are not supported). <a>unittest/unittest.expectAsync.id</a> can be used to provide more\ndescriptive error messages if the callback is called more often than\nexpected. <a>unittest/unittest.expectAsync.max</a> can be used to specify an upper bound on the number of\ncalls; if this is exceeded the test will fail (or be marked as in error if\nit was already complete). A value of 0 for <a>unittest/unittest.expectAsync.max</a> (the default) will set\nthe upper bound to the same value as <a>unittest/unittest.expectAsync.count</a>; i.e. the callback should be\ncalled exactly <a>unittest/unittest.expectAsync.count</a> times. A value of -1 for <a>unittest/unittest.expectAsync.max</a> will mean no upper\nbound.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"solo_test":{"name":"solo_test","qualifiedName":"unittest/unittest.solo_test","comment":"<p>Creates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.</p>\n<p>If we use <a>unittest/unittest.solo_test</a> (or <a>unittest/unittest.solo_group</a>) instead of test, then all non-solo\ntests will be disabled. Note that if we use <a>unittest/unittest.solo_group</a>, all tests in\nthe group will be enabled, regardless of whether they use <a>unittest/unittest.test</a> or\n<a>unittest/unittest.solo_test</a>, or whether they are in a nested <a>unittest/unittest.group</a> vs <a>unittest/unittest.solo_group</a>. Put\nanother way, if there are any calls to <a>unittest/unittest.solo_test</a> or <a>unittest/unittest.solo_group</a> in a test\nfile, all tests that are not inside a <a>unittest/unittest.solo_group</a> will be disabled unless\nthey are <a>unittest/unittest.solo_test</a>s.</p>\n<p><a>unittest/unittest.skip_test</a> and <a>unittest/unittest.skip_group</a> take precedence over soloing, by virtue of the\nfact that they are effectively no-ops.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.TestFunction","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"skip_test":{"name":"skip_test","qualifiedName":"unittest/unittest.skip_test","comment":"<p>Convenience function for skipping a test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.TestFunction","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"test":{"name":"test","qualifiedName":"unittest/unittest.test","comment":"<p>Creates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.TestFunction","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"logMessage":{"name":"logMessage","qualifiedName":"unittest/unittest.logMessage","comment":"<p>Can be called by tests to log status. Tests should use this\ninstead of <a>dart-core.print</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"DefaultFailureHandler","qualifiedName":"unittest/unittest.DefaultFailureHandler"},{"name":"CustomMatcher","qualifiedName":"unittest/unittest.CustomMatcher","preview":"<p>A useful utility class for implementing other matchers through inheritance.\nDerived classes should call the base constructor with a feature name and\ndescription, and an instance matcher, and should implement the\n<a>unittest/unittest.CustomMatcher.featureValueOf</a> abstract method.</p>"},{"name":"TypeMatcher","qualifiedName":"unittest/unittest.TypeMatcher"},{"name":"Throws","qualifiedName":"unittest/unittest.Throws"},{"name":"isInstanceOf","qualifiedName":"unittest/unittest.isInstanceOf","preview":"<p>Returns a matcher that matches if an object is an instance\nof type (or a subtype).</p>"},{"name":"TestCase","qualifiedName":"unittest/unittest.TestCase","preview":"<p>Represents the state for an individual unit test.</p>"},{"name":"SimpleConfiguration","qualifiedName":"unittest/unittest.SimpleConfiguration","preview":"<p>Hooks to configure the unittest library for different platforms. This class\nimplements the API in a platform-independent way. Tests that want to take\nadvantage of the platform can create a subclass and override methods from\nthis class.</p>"},{"name":"Configuration","qualifiedName":"unittest/unittest.Configuration","preview":"<p>Describes the interface used by the unit test system for communicating the\nresults of a test run.</p>"}],"typedef":{"TestFunction":{"name":"TestFunction","qualifiedName":"unittest/unittest.TestFunction","comment":"<p>Signature for a test function.</p>","return":"dynamic","parameters":{},"annotations":[],"generics":{},"preview":"<p>Signature for a test function.</p>"}},"error":[{"name":"TestFailure","qualifiedName":"unittest/unittest.TestFailure","preview":"<p>The objects thrown by the default failure handler.</p>"}]},"packageName":"unittest","packageIntro":""}