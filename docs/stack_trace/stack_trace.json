{"name":"stack_trace","qualifiedName":"stack_trace/stack_trace","comment":"<p>Stack trace generation and parsing.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following to your <code>pubspec.yaml</code>\nfile.</p>\n<pre><code>dependencies:\n  stack_trace: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>For more information, see the\n<a href=\"http://pub.dartlang.org/packages/stack_trace\">stack_trace package on pub.dartlang.org</a>.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"Trace","qualifiedName":"stack_trace/stack_trace.Trace","preview":"<p>A stack trace, comprised of a list of stack frames.</p>"},{"name":"Frame","qualifiedName":"stack_trace/stack_trace.Frame","preview":"<p>A single stack frame. Each frame points to a precise location in Dart code.</p>"},{"name":"Chain","qualifiedName":"stack_trace/stack_trace.Chain","preview":"<p>A chain of stack traces.</p>"}],"typedef":{"ChainHandler":{"name":"ChainHandler","qualifiedName":"stack_trace/stack_trace.ChainHandler","comment":"<p>A function that handles errors in the zone wrapped by [Chain.capture].</p>","return":"void","parameters":{"error":{"name":"error","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"chain":{"name":"chain","optional":false,"named":false,"default":false,"type":[{"outer":"stack_trace/stack_trace.Chain","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{},"preview":"<p>A function that handles errors in the zone wrapped by [Chain.capture].</p>"}},"error":[]},"packageName":"stack_trace","packageIntro":"<p>This library provides the ability to parse, inspect, and manipulate stack traces\nproduced by the underlying Dart implementation. It also provides functions to\nproduce string representations of stack traces in a more readable format than\nthe native <a>dart-core</a> implementation.</p>\n<p><code>Trace</code>s can be parsed from native <a>dart-core</a>s using <code>Trace.from</code>, or captured\nusing <code>Trace.current</code>. Native <a>dart-core</a>s can also be directly converted to\nhuman-readable strings using <code>Trace.format</code>.</p>\n<p>Here's an example native stack trace from debugging this library:</p>\n<pre><code>#0      Object.noSuchMethod (dart:core-patch:1884:25)\n#1      Trace.terse.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/src/trace.dart:47:21)\n#2      IterableMixinWorkaround.reduce (dart:collection:29:29)\n#3      List.reduce (dart:core-patch:1247:42)\n#4      Trace.terse (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/src/trace.dart:40:35)\n#5      format (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/stack_trace.dart:24:28)\n#6      main.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/test.dart:21:29)\n#7      _CatchErrorFuture._sendError (dart:async:525:24)\n#8      _FutureImpl._setErrorWithoutAsyncTrace (dart:async:393:26)\n#9      _FutureImpl._setError (dart:async:378:31)\n#10     _ThenFuture._sendValue (dart:async:490:16)\n#11     _FutureImpl._handleValue.&lt;anonymous closure&gt; (dart:async:349:28)\n#12     Timer.run.&lt;anonymous closure&gt; (dart:async:2402:21)\n#13     Timer.Timer.&lt;anonymous closure&gt; (dart:async-patch:15:15)\n</code></pre>\n<p>and its human-readable representation:</p>\n<pre><code>dart:core-patch                             Object.noSuchMethod\npkg/stack_trace/lib/src/trace.dart 47:21    Trace.terse.&lt;fn&gt;\ndart:collection                             IterableMixinWorkaround.reduce\ndart:core-patch                             List.reduce\npkg/stack_trace/lib/src/trace.dart 40:35    Trace.terse\npkg/stack_trace/lib/stack_trace.dart 24:28  format\ntest.dart 21:29                             main.&lt;fn&gt;\ndart:async                                  _CatchErrorFuture._sendError\ndart:async                                  _FutureImpl._setErrorWithoutAsyncTrace\ndart:async                                  _FutureImpl._setError\ndart:async                                  _ThenFuture._sendValue\ndart:async                                  _FutureImpl._handleValue.&lt;fn&gt;\ndart:async                                  Timer.run.&lt;fn&gt;\ndart:async-patch                            Timer.Timer.&lt;fn&gt;\n</code></pre>\n<p>You can further clean up the stack trace using <code>Trace.terse</code>. This folds\ntogether multiple stack frames from the Dart core libraries, so that only the\ncore library method that was directly called from user code is visible. For\nexample:</p>\n<pre><code>dart:core                                   Object.noSuchMethod\npkg/stack_trace/lib/src/trace.dart 47:21    Trace.terse.&lt;fn&gt;\ndart:core                                   List.reduce\npkg/stack_trace/lib/src/trace.dart 40:35    Trace.terse\npkg/stack_trace/lib/stack_trace.dart 24:28  format\ntest.dart 21:29                             main.&lt;fn&gt;\ndart:async                                  Timer.Timer.&lt;fn&gt;\n</code></pre>\n<h2>Stack Chains</h2>\n<p>This library also provides the ability to capture \"stack chains\" with the\n<code>Chain</code> class. When writing asynchronous code, a single stack trace isn't very\nuseful, since the call stack is unwound every time something async happens. A\nstack chain tracks stack traces through asynchronous calls, so that you can see\nthe full path from <code>main</code> down to the error.</p>\n<p>To use stack chains, just wrap the code that you want to track in\n<code>Chain.capture</code>. This will create a new <a href=\"https://api.dartlang.org/apidocs/channels/stable/#dart-async.Zone\">Zone</a> in which stack traces are\nrecorded and woven into chains every time an asynchronous call occurs. Zones are\nsticky, too, so any asynchronous operations started in the <code>Chain.capture</code>\ncallback will have their chains tracked, as will asynchronous operations they\nstart and so on.</p>\n<p>Here's an example of some code that doesn't capture its stack chains:</p>\n<pre class=\"dart\"><code>import 'dart:async';\n\nvoid main() {\n  scheduleAsync();\n}\n\nvoid scheduleAsync() {\n  return new Future.delayed(new Duration(seconds: 1))\n      .then((_) =&gt; runAsync());\n}\n\nvoid runAsync() {\n  throw 'oh no!';\n}\n</code></pre>\n<p>If we run this, it prints the following:</p>\n<pre><code>Uncaught Error: oh no!\nStack Trace: \n#0      runAsync (file:///usr/local/google-old/home/goog/dart/dart/test.dart:13:3)\n#1      scheduleAsync.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/test.dart:9:28)\n#2      _rootRunUnary (dart:async/zone.dart:717)\n#3      _RootZone.runUnary (dart:async/zone.dart:854)\n#4      _Future._propagateToListeners.handleValueCallback (dart:async/future_impl.dart:488)\n#5      _Future._propagateToListeners (dart:async/future_impl.dart:571)\n#6      _Future._complete (dart:async/future_impl.dart:317)\n#7      _SyncCompleter.complete (dart:async/future_impl.dart:44)\n#8      Future.Future.delayed.&lt;anonymous closure&gt; (dart:async/future.dart:219)\n#9      _createTimer.&lt;anonymous closure&gt; (dart:async-patch/timer_patch.dart:11)\n#10     _handleTimeout (dart:io/timer_impl.dart:292)\n#11     _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:115)\n</code></pre>\n<p>Notice how there's no mention of <code>main</code> in that stack trace. All we know is that\nthe error was in <code>runAsync</code>; we don't know why <code>runAsync</code> was called.</p>\n<p>Now let's look at the same code with stack chains captured:</p>\n<pre class=\"dart\"><code>import 'dart:async';\n\nimport 'package:stack_trace/stack_trace.dart';\n\nvoid main() {\n  Chain.capture(() {\n    scheduleAsync();\n  });\n}\n\nvoid scheduleAsync() {\n  new Future.delayed(new Duration(seconds: 1))\n      .then((_) =&gt; runAsync());\n}\n\nvoid runAsync() {\n  throw 'oh no!';\n}\n</code></pre>\n<p>Now if we run it, it prints this:</p>\n<pre><code>Uncaught Error: oh no!\nStack Trace: \ntest.dart 17:3                                                runAsync\ntest.dart 13:28                                               scheduleAsync.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 129:26  registerUnaryCallback.&lt;fn&gt;.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 174:15  StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 177:7   StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 175:7   StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 129:18  registerUnaryCallback.&lt;fn&gt;\ndart:async/zone.dart 717                                      _rootRunUnary\ndart:async/zone.dart 449                                      _ZoneDelegate.runUnary\ndart:async/zone.dart 654                                      _CustomizedZone.runUnary\ndart:async/future_impl.dart 488                               _Future._propagateToListeners.handleValueCallback\ndart:async/future_impl.dart 571                               _Future._propagateToListeners\ndart:async/future_impl.dart 317                               _Future._complete\ndart:async/future_impl.dart 44                                _SyncCompleter.complete\ndart:async/future.dart 219                                    Future.Future.delayed.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 174:15  StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 119:52  registerCallback.&lt;fn&gt;\ndart:async/zone.dart 706                                      _rootRun\ndart:async/zone.dart 440                                      _ZoneDelegate.run\ndart:async/zone.dart 650                                      _CustomizedZone.run\ndart:async/zone.dart 561                                      _BaseZone.runGuarded\ndart:async/zone.dart 586                                      _BaseZone.bindCallback.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 174:15  StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 119:52  registerCallback.&lt;fn&gt;\ndart:async/zone.dart 710                                      _rootRun\ndart:async/zone.dart 440                                      _ZoneDelegate.run\ndart:async/zone.dart 650                                      _CustomizedZone.run\ndart:async/zone.dart 561                                      _BaseZone.runGuarded\ndart:async/zone.dart 586                                      _BaseZone.bindCallback.&lt;fn&gt;\ndart:async-patch/timer_patch.dart 11                          _createTimer.&lt;fn&gt;\ndart:io/timer_impl.dart 292                                   _handleTimeout\ndart:isolate-patch/isolate_patch.dart 115                     _RawReceivePortImpl._handleMessage\n===== asynchronous gap ===========================\ndart:async/zone.dart 476                   _ZoneDelegate.registerUnaryCallback\ndart:async/zone.dart 666                   _CustomizedZone.registerUnaryCallback\ndart:async/future_impl.dart 164            _Future._Future._then\ndart:async/future_impl.dart 187            _Future.then\ntest.dart 13:12                            scheduleAsync\ntest.dart 7:18                             main.&lt;fn&gt;\ndart:async/zone.dart 710                   _rootRun\ndart:async/zone.dart 440                   _ZoneDelegate.run\ndart:async/zone.dart 650                   _CustomizedZone.run\ndart:async/zone.dart 944                   runZoned\npackage:stack_trace/src/chain.dart 93:20   Chain.capture\ntest.dart 6:16                             main\ndart:isolate-patch/isolate_patch.dart 216  _startIsolate.isolateStartHandler\ndart:isolate-patch/isolate_patch.dart 115  _RawReceivePortImpl._handleMessage\n</code></pre>\n<p>That's a lot of text! If you look closely, though, you can see that <code>main</code> is\nlisted in the first trace in the chain.</p>\n<p>Thankfully, you can call <code>Chain.terse</code> just like <code>Trace.terse</code> to get rid of all\nthe frames you don't care about. The terse version of the stack chain above is\nthis:</p>\n<pre><code>test.dart 17:3   runAsync\ntest.dart 13:28  scheduleAsync.&lt;fn&gt;\ndart:isolate     _RawReceivePortImpl._handleMessage\n===== asynchronous gap ===========================\ndart:async                                _Future.then\ntest.dart 13:12                           scheduleAsync\ntest.dart 7:18                            main.&lt;fn&gt;\npackage:stack_trace/src/chain.dart 93:20  Chain.capture\ntest.dart 6:16                            main\ndart:isolate                              _RawReceivePortImpl._handleMessage\n</code></pre>\n<p>That's a lot easier to understand!</p>\n<h3><code>Chain.track</code></h3>\n<p>For the most part <code>Chain.capture</code> will notice when an error is thrown and\nassociate the correct stack chain with it. However, there are some cases where\nexceptions won't be automatically detected: any <code>Future</code> constructor,\n<code>Completer.completeError</code>, <code>Stream.addError</code>, and libraries that use these such\nas <code>dart:io</code> and <code>dart:async</code>. For these, all you need to do is wrap the Future\nor Stream in a call to <code>Chain.track</code> and the errors will be tracked correctly.</p>"}