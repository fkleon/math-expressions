{"name":"HttpClientRequest","qualifiedName":"dart-io.HttpClientRequest","comment":"<p>HTTP request for a client connection.</p>\n<p>To set up a request, set the headers using the headers property\nprovided in this class and write the data to the body of the request.\nHttpClientRequest is an <a>dart-io.IOSink</a>. Use the methods from IOSink,\nsuch as writeCharCode(), to write the body of the HTTP\nrequest. When one of the IOSink methods is used for the first\ntime, the request header is sent. Calling any methods that\nchange the header after it is sent throws an exception.</p>\n<p>When writing string data through the <a>dart-io.IOSink</a> the\nencoding used is determined from the \"charset\" parameter of\nthe \"Content-Type\" header.</p>\n<pre><code>HttpClientRequest request = ...\nrequest.headers.contentType\n    = new ContentType(\"application\", \"json\", charset: \"utf-8\");\nrequest.write(...);  // Strings written will be UTF-8 encoded.\n</code></pre>\n<p>If no charset is provided the default of ISO-8859-1 (Latin 1) is\nbe used.</p>\n<pre><code>HttpClientRequest request = ...\nrequest.headers.add(HttpHeaders.CONTENT_TYPE, \"text/plain\");\nrequest.write(...);  // Strings written will be ISO-8859-1 encoded.\n</code></pre>\n<p>An exception is thrown if you use an unsupported encoding and the\n<code>write()</code> method being used takes a string parameter.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":["dart-io.IOSink"],"subclass":[],"variables":{"persistentConnection":{"name":"persistentConnection","qualifiedName":"dart-io.HttpClientRequest.persistentConnection","comment":"<p>Gets and sets the requested persistent connection state.</p>\n<p>The default value is <code>true</code>.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"followRedirects":{"name":"followRedirects","qualifiedName":"dart-io.HttpClientRequest.followRedirects","comment":"<p>Set this property to <code>true</code> if this request should\nautomatically follow redirects. The default is <code>true</code>.</p>\n<p>Automatic redirect will only happen for \"GET\" and \"HEAD\" requests\nand only for the status codes <code>HttpHeaders.MOVED_PERMANENTLY</code>\n(301), <code>HttpStatus.FOUND</code> (302),\n<code>HttpStatus.MOVED_TEMPORARILY</code> (302, alias for\n<code>HttpStatus.FOUND</code>), <code>HttpStatus.SEE_OTHER</code> (303) and\n<code>HttpStatus.TEMPORARY_REDIRECT</code> (307). For\n<code>HttpStatus.SEE_OTHER</code> (303) autmatic redirect will also happen\nfor \"POST\" requests with the method changed to \"GET\" when\nfollowing the redirect.</p>\n<p>All headers added to the request will be added to the redirection\nrequest(s). However, any body send with the request will not be\npart of the redirection request(s).</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"maxRedirects":{"name":"maxRedirects","qualifiedName":"dart-io.HttpClientRequest.maxRedirects","comment":"<p>Set this property to the maximum number of redirects to follow\nwhen <a>dart-io.HttpClientRequest.followRedirects</a> is <code>true</code>. If this number is exceeded the\nonError callback will be called with a <a>dart-io.RedirectException</a>.</p>\n<p>The default value is 5.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"contentLength":{"name":"contentLength","qualifiedName":"dart-io.HttpClientRequest.contentLength","comment":"<p>Gets and sets the content length of the request. If the size of\nthe request is not known in advance set content length to -1,\nwhich is also the default.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]}},"inheritedVariables":{"encoding":{"name":"encoding","qualifiedName":"dart-io.IOSink.encoding","comment":"<p>The <a>dart-convert.Encoding</a> used when writing strings. Depending on the\nunderlying consumer this property might be mutable.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"method":{"name":"method","qualifiedName":"dart-io.HttpClientRequest.method","comment":"<p>The method of the request.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"uri":{"name":"uri","qualifiedName":"dart-io.HttpClientRequest.uri","comment":"<p>The uri of the request.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Uri","inner":[]}],"parameters":{},"annotations":[]},"headers":{"name":"headers","qualifiedName":"dart-io.HttpClientRequest.headers","comment":"<p>Returns the request headers.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.HttpHeaders","inner":[]}],"parameters":{},"annotations":[]},"cookies":{"name":"cookies","qualifiedName":"dart-io.HttpClientRequest.cookies","comment":"<p>Cookies to present to the server (in the 'cookie' header).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-io.Cookie","inner":[]}]}],"parameters":{},"annotations":[]},"done":{"name":"done","qualifiedName":"dart-io.HttpClientRequest.done","comment":"<p>A <a>dart-io.HttpClientResponse</a> future that will complete once the response is\navailable. If an error occurs before the response is available, this\nfuture will complete with an error.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientResponse","inner":[]}]}],"parameters":{},"annotations":[]},"connectionInfo":{"name":"connectionInfo","qualifiedName":"dart-io.HttpClientRequest.connectionInfo","comment":"<p>Get information about the client connection. Returns <code>null</code> if the socket\nis not available.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.HttpConnectionInfo","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"close":{"name":"close","qualifiedName":"dart-io.HttpClientRequest.close","comment":"<p>Close the request for input. Returns the value of <a>dart-io.HttpClientRequest.done</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientResponse","inner":[]}]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-io.HttpClientRequest.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.HttpClientRequest.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.HttpClientRequest.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"done":{"name":"done","qualifiedName":"dart-io.HttpClientRequest.done","comment":"<p>Get a future that will complete when the consumer closes, or when an\nerror occurs. This future is identical to the future returned by\n<a>dart-io.HttpClientRequest.close</a>.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.done","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.HttpClientRequest.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.HttpClientRequest.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.HttpClientRequest.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"dart-io.HttpClientRequest.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.HttpClientRequest.noSuchMethod","comment":"<p><a>dart-io.HttpClientRequest.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.HttpClientRequest.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.HttpClientRequest.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.HttpClientRequest.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"write":{"name":"write","qualifiedName":"dart-io.HttpClientRequest.write","comment":"<p>Converts <a>dart-io.HttpClientRequest.write.obj</a> to a String by invoking <a>dart-io.HttpClientRequest.toString</a> and\n<a>dart-io.HttpClientRequest.add</a>s the encoding of the result to the target consumer.</p>\n<p>This operation is non-blocking. See <a>dart-io.HttpClientRequest.flush</a> or <a>dart-io.HttpClientRequest.done</a> for how to get any\nerrors generated by this call.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.write","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"obj":{"name":"obj","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"writeAll":{"name":"writeAll","qualifiedName":"dart-io.HttpClientRequest.writeAll","comment":"<p>Iterates over the given <a>dart-io.HttpClientRequest.writeAll.objects</a> and <a>dart-io.HttpClientRequest.write</a>s them in sequence.</p>\n<p>If <a>dart-io.HttpClientRequest.writeAll.separator</a> is provided, a <code>write</code> with the <code>separator</code> is performed\nbetween any two elements of <code>objects</code>.</p>\n<p>This operation is non-blocking. See <a>dart-io.HttpClientRequest.flush</a> or <a>dart-io.HttpClientRequest.done</a> for how to get any\nerrors generated by this call.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.writeAll","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"objects":{"name":"objects","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":"null","annotations":[]},"separator":{"name":"separator","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"StringConstant(\"\")","annotations":[]}},"annotations":[]},"writeln":{"name":"writeln","qualifiedName":"dart-io.HttpClientRequest.writeln","comment":"<p>Converts <a>dart-io.HttpClientRequest.writeln.obj</a> to a String by invoking <a>dart-io.HttpClientRequest.toString</a> and\nwrites the result to <code>this</code>, followed by a newline.</p>\n<p>This operation is non-blocking. See <a>dart-io.HttpClientRequest.flush</a> or <a>dart-io.HttpClientRequest.done</a> for how to get any\nerrors generated by this call.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.writeln","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"obj":{"name":"obj","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.Object","inner":[]}],"value":"StringConstant(\"\")","annotations":[]}},"annotations":[]},"writeCharCode":{"name":"writeCharCode","qualifiedName":"dart-io.HttpClientRequest.writeCharCode","comment":"<p>Writes the <a>dart-io.HttpClientRequest.writeCharCode.charCode</a> to <code>this</code>.</p>\n<p>This method is equivalent to <code>write(new String.fromCharCode(charCode))</code>.</p>\n<p>This operation is non-blocking. See <a>dart-io.HttpClientRequest.flush</a> or <a>dart-io.HttpClientRequest.done</a> for how to get any\nerrors generated by this call.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.writeCharCode","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"charCode":{"name":"charCode","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"add":{"name":"add","qualifiedName":"dart-io.HttpClientRequest.add","comment":"<p>Adds <a>dart-io.HttpClientRequest.add.data</a> to the target consumer, ignoring <a>dart-io.IOSink.encoding</a>.</p>\n<p>The <a>dart-io.IOSink.encoding</a> does not apply to this method, and the <code>data</code> list is passed\ndirectly to the target consumer as a stream event.</p>\n<p>This function must not be called when a stream is currently being added\nusing <a>dart-io.HttpClientRequest.addStream</a>.</p>\n<p>This operation is non-blocking. See <a>dart-io.HttpClientRequest.flush</a> or <a>dart-io.HttpClientRequest.done</a> for how to get any\nerrors generated by this call.</p>\n<p>The data list should not be modified after it has been passed to <code>add</code>.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.add","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"data":{"name":"data","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":"null","annotations":[]}},"annotations":[]},"close":{"name":"close","qualifiedName":"dart-io.HttpClientRequest.close","comment":"<p>Close the target consumer.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.close","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{},"annotations":[]},"addError":{"name":"addError","qualifiedName":"dart-io.HttpClientRequest.addError","comment":"<p>Passes the error to the target consumer as an error event.</p>\n<p>This function must not be called when a stream is currently being added\nusing <a>dart-io.HttpClientRequest.addStream</a>.</p>\n<p>This operation is non-blocking. See <a>dart-io.HttpClientRequest.flush</a> or <a>dart-io.HttpClientRequest.done</a> for how to get any\nerrors generated by this call.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.addError","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"error":{"name":"error","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"stackTrace":{"name":"stackTrace","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.StackTrace","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"addStream":{"name":"addStream","qualifiedName":"dart-io.HttpClientRequest.addStream","comment":"<p>Adds all elements of the given <a>dart-io.HttpClientRequest.addStream.stream</a> to <code>this</code>.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.addStream","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"stream":{"name":"stream","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"value":"null","annotations":[]}},"annotations":[]},"flush":{"name":"flush","qualifiedName":"dart-io.HttpClientRequest.flush","comment":"<p>Returns a <a>dart-async.Future</a> that completes once all buffered data is accepted by the\nto underlying <a>dart-async.StreamConsumer</a>.</p>\n<p>It's an error to call this method, while an <a>dart-io.HttpClientRequest.addStream</a> is incomplete.</p>\n<p>NOTE: This is not necessarily the same as the data being flushed by the\noperating system.</p>","commentFrom":"","inheritedFrom":"dart-io.IOSink.flush","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}