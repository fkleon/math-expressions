{"name":"File","qualifiedName":"dart-io.File","comment":"<p>A reference to a file on the file system.</p>\n<p>A File instance is an object that holds a <a>dart-io.File.path</a> on which operations can\nbe performed.\nYou can get the parent directory of the file using the getter <a>dart-io.FileSystemEntity.parent</a>,\na property inherited from <a>dart-io.FileSystemEntity</a>.</p>\n<p>Create a new File object with a pathname to access the specified file on the\nfile system from your program.</p>\n<pre><code>var myFile = new File('file.txt');\n</code></pre>\n<p>The File class contains methods for manipulating files and their contents.\nUsing methods in this class, you can open and close files, read to and write\nfrom them, create and delete them, and check for their existence.</p>\n<p>When reading or writing a file, you can use streams (with <a>dart-io.File.openRead</a>),\nrandom access operations (with <a>dart-io.File.open</a>),\nor convenience methods such as <a>dart-io.File.readAsString</a>,</p>\n<p>Most methods in this class occur in synchronous and asynchronous pairs,\nfor example, <a>dart-io.File.readAsString</a> and <a>dart-io.File.readAsStringSync</a>.\nUnless you have a specific reason for using the synchronous version\nof a method, prefer the asynchronous version to avoid blocking your program.</p>\n<h2>If path is a link</h2>\n<p>If <a>dart-io.File.path</a> is a symbolic link, rather than a file,\nthen the methods of File operate on the ultimate target of the\nlink, except for <a>dart-io.FileSystemEntity.delete</a> and <a>dart-io.FileSystemEntity.deleteSync</a>, which operate on\nthe link.</p>\n<h2>Read from a file</h2>\n<p>The following code sample reads the entire contents from a file as a string\nusing the asynchronous <a>dart-io.File.readAsString</a> method:</p>\n<pre><code>import 'dart:async';\nimport 'dart:io';\n\nvoid main() {\n  new File('file.txt').readAsString().then((String contents) {\n    print(contents);\n  });\n}\n</code></pre>\n<p>A more flexible and useful way to read a file is with a <a>dart-async.Stream</a>.\nOpen the file with <a>dart-io.File.openRead</a>, which returns a stream that\nprovides the data in the file as chunks of bytes.\nListen to the stream for data and process as needed.\nYou can use various transformers in succession to manipulate the\ndata into the required format or to prepare it for output.</p>\n<p>You might want to use a stream to read large files,\nto manipulate the data with tranformers,\nor for compatibility with another API, such as <a>dart-io.WebSocket</a>s.</p>\n<pre><code>import 'dart:io';\nimport 'dart:convert';\nimport 'dart:async';\n\nmain() {\n  final file = new File('file.txt');\n  Stream&lt;List&lt;int&gt;&gt; inputStream = file.openRead();\n\n  inputStream\n    .transform(UTF8.decoder)       // Decode bytes to UTF8.\n    .transform(new LineSplitter()) // Convert stream to individual lines.\n    .listen((String line) {        // Process results.\n        print('$line: ${line.length} bytes');\n      },\n      onDone: () { print('File is now closed.'); },\n      onError: (e) { print(e.toString()); });\n}\n</code></pre>\n<h2>Write to a file</h2>\n<p>To write a string to a file, use the <a>dart-io.File.writeAsString</a> method:</p>\n<pre><code>import 'dart:io';\n\nvoid main() {\n  final filename = 'file.txt';\n  new File(filename).writeAsString('some content')\n    .then((File file) {\n      // Do something with the file.\n    });\n}\n</code></pre>\n<p>You can also write to a file using a <a>dart-async.Stream</a>. Open the file with\n<a>dart-io.File.openWrite</a>, which returns a stream to which you can write data.\nBe sure to close the file with the close method.</p>\n<pre><code>import 'dart:io';\n\nvoid main() {\n  var file = new File('file.txt');\n  var sink = file.openWrite();\n  sink.write('FILE ACCESSED ${new DateTime.now()}\\n');\n\n  // Close the IOSink to free system resources.\n  sink.close();\n}\n</code></pre>\n<h2>The use of Futures</h2>\n<p>To avoid unintentional blocking of the program,\nseveral methods use a <a>dart-async.Future</a> to return a value. For example,\nthe <a>dart-io.File.length</a> method, which gets the length of a file, returns a Future.\nUse <code>then</code> to register a callback function, which is called when\nthe value is ready.</p>\n<pre><code>import 'dart:io';\n\nmain() {\n  final file = new File('file.txt');\n\n  file.length().then((len) {\n    print(len);\n  });\n}\n</code></pre>\n<p>In addition to length, the <a>dart-io.FileSystemEntity.exists</a>, <a>dart-io.File.lastModified</a>, <a>dart-io.FileSystemEntity.stat</a>, and\nother methods, return Futures.</p>\n<h2>Other resources</h2><ul><li>\n<p><a href=\"https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks\">Dart by Example</a>\nprovides additional task-oriented code samples that show how to use \nvarious API from the Directory class and the related <a>dart-io.File</a> class.</p></li><li>\n<p><a href=\"https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps\">I/O for Command-Line Apps</a>\na section from <em>A Tour of the Dart Libraries</em>\ncovers files and directories.</p></li><li>\n<p><a href=\"https://www.dartlang.org/docs/tutorials/cmdline/\">Write Command-Line Apps</a>,\na tutorial about writing command-line apps, includes information\nabout files and directories.</p></li></ul>","isAbstract":true,"superclass":"dart-io.FileSystemEntity","implements":[],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"absolute":{"name":"absolute","qualifiedName":"dart-io.File.absolute","comment":"<p>Returns a <a>dart-io.File</a> instance whose path is the absolute path to this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.File","inner":[]}],"parameters":{},"annotations":[]},"path":{"name":"path","qualifiedName":"dart-io.File.path","comment":"<p>Get the path of the file.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"dart-io.File.File-","comment":"<p>Create a File object.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.File","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"fromUri":{"name":"fromUri","qualifiedName":"dart-io.File.File-fromUri","comment":"<p>Create a File object from a URI.</p>\n<p>If <a>dart-io.File.File-fromUri.uri</a> cannot reference a file this throws <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.File","inner":[]}],"parameters":{"uri":{"name":"uri","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"create":{"name":"create","qualifiedName":"dart-io.File.create","comment":"<p>Create the file. Returns a <code>Future&lt;File&gt;</code> that completes with\nthe file when it has been created.</p>\n<p>If <a>dart-io.File.create.recursive</a> is false, the default, the file is created only if\nall directories in the path exist. If <a>dart-io.File.create.recursive</a> is true, all\nnon-existing path components are created.</p>\n<p>Existing files are left untouched by <a>dart-io.File.create</a>. Calling <a>dart-io.File.create</a> on an\nexisting file might fail if there are restrictive permissions on\nthe file.</p>\n<p>Completes the future with a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.File","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"createSync":{"name":"createSync","qualifiedName":"dart-io.File.createSync","comment":"<p>Synchronously create the file. Existing files are left untouched\nby <a>dart-io.File.createSync</a>. Calling <a>dart-io.File.createSync</a> on an existing file might fail\nif there are restrictive permissions on the file.</p>\n<p>If <a>dart-io.File.createSync.recursive</a> is false, the default, the file is created\nonly if all directories in the path exist.\nIf <a>dart-io.File.createSync.recursive</a> is true, all non-existing path components are created.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.File.rename","comment":"<p>Renames this file. Returns a <code>Future&lt;File&gt;</code> that completes\nwith a <a>dart-io.File</a> instance for the renamed file.</p>\n<p>If <a>dart-io.File.rename.newPath</a> identifies an existing file, that file is\nreplaced. If <a>dart-io.File.rename.newPath</a> identifies an existing directory, the\noperation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.File","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.File.renameSync","comment":"<p>Synchronously renames this file. Returns a <a>dart-io.File</a>\ninstance for the renamed file.</p>\n<p>If <a>dart-io.File.renameSync.newPath</a> identifies an existing file, that file is\nreplaced. If <a>dart-io.File.renameSync.newPath</a> identifies an existing directory the\noperation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.File","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"copy":{"name":"copy","qualifiedName":"dart-io.File.copy","comment":"<p>Copy this file. Returns a <code>Future&lt;File&gt;</code> that completes\nwith a <a>dart-io.File</a> instance for the copied file.</p>\n<p>If <a>dart-io.File.copy.newPath</a> identifies an existing file, that file is\nreplaced. If <a>dart-io.File.copy.newPath</a> identifies an existing directory, the\noperation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.File","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"copySync":{"name":"copySync","qualifiedName":"dart-io.File.copySync","comment":"<p>Synchronously copy this file. Returns a <a>dart-io.File</a>\ninstance for the copied file.</p>\n<p>If <a>dart-io.File.copySync.newPath</a> identifies an existing file, that file is\nreplaced. If <a>dart-io.File.copySync.newPath</a> identifies an existing directory the\noperation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.File","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"length":{"name":"length","qualifiedName":"dart-io.File.length","comment":"<p>Get the length of the file. Returns a <code>Future&lt;int&gt;</code> that\ncompletes with the length in bytes.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{},"annotations":[]},"lengthSync":{"name":"lengthSync","qualifiedName":"dart-io.File.lengthSync","comment":"<p>Synchronously get the length of the file.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"lastModified":{"name":"lastModified","qualifiedName":"dart-io.File.lastModified","comment":"<p>Get the last-modified time of the file. Returns a\n<code>Future&lt;DateTime&gt;</code> that completes with a <a>dart-core.DateTime</a> object for the\nmodification date.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.DateTime","inner":[]}]}],"parameters":{},"annotations":[]},"lastModifiedSync":{"name":"lastModifiedSync","qualifiedName":"dart-io.File.lastModifiedSync","comment":"<p>Get the last-modified time of the file. Throws an exception\nif the file does not exist.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.DateTime","inner":[]}],"parameters":{},"annotations":[]},"open":{"name":"open","qualifiedName":"dart-io.File.open","comment":"<p>Open the file for random access operations. Returns a\n<code>Future&lt;RandomAccessFile&gt;</code> that completes with the opened\nrandom access file. <a>dart-io.RandomAccessFile</a>s must be closed using the\n<a>dart-io.RandomAccessFile.close</a> method.</p>\n<p>Files can be opened in three modes:</p>\n<p><a>dart-io.FileMode.READ</a>: open the file for reading.</p>\n<p><a>dart-io.FileMode.WRITE</a>: open the file for both reading and writing and\ntruncate the file to length zero. If the file does not exist the\nfile is created.</p>\n<p><a>dart-io.FileMode.APPEND</a>: same as <a>dart-io.FileMode.WRITE</a> except that the file is\nnot truncated.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.RandomAccessFile","inner":[]}]}],"parameters":{"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]}},"annotations":[]},"openSync":{"name":"openSync","qualifiedName":"dart-io.File.openSync","comment":"<p>Synchronously open the file for random access operations. The\nresult is a <a>dart-io.RandomAccessFile</a> on which random access operations\ncan be performed. Opened <a>dart-io.RandomAccessFile</a>s must be closed using\nthe <a>dart-io.RandomAccessFile.close</a> method.</p>\n<p>See <a>dart-io.File.open</a> for information on the <a>dart-io.File.openSync.mode</a> argument.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.RandomAccessFile","inner":[]}],"parameters":{"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]}},"annotations":[]},"openRead":{"name":"openRead","qualifiedName":"dart-io.File.openRead","comment":"<p>Create a new independent <a>dart-async.Stream</a> for the contents of this file.</p>\n<p>If <a>dart-io.File.openRead.start</a> is present, the file will be read from byte-offset <a>dart-io.File.openRead.start</a>.\nOtherwise from the beginning (index 0).</p>\n<p>If <a>dart-io.File.openRead.end</a> is present, only up to byte-index <a>dart-io.File.openRead.end</a> will be read. Otherwise,\nuntil end of file.</p>\n<p>In order to make sure that system resources are freed, the stream\nmust be read to completion or the subscription on the stream must\nbe cancelled.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"parameters":{"start":{"name":"start","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"openWrite":{"name":"openWrite","qualifiedName":"dart-io.File.openWrite","comment":"<p>Creates a new independent <a>dart-io.IOSink</a> for the file. The\n<a>dart-io.IOSink</a> must be closed when no longer used, to free\nsystem resources.</p>\n<p>An <a>dart-io.IOSink</a> for a file can be opened in two modes:</p><ul><li><a>dart-io.FileMode.WRITE</a>: truncates the file to length zero.</li><li>\n<p><a>dart-io.FileMode.APPEND</a>: sets the initial write position to the end\n  of the file.</p></li></ul>\n<p> When writing strings through the returned <a>dart-io.IOSink</a> the encoding\n specified using <a>dart-io.File.openWrite.encoding</a> will be used. The returned <a>dart-io.IOSink</a>\n has an <code>encoding</code> property which can be changed after the\n <a>dart-io.IOSink</a> has been created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.IOSink","inner":[]}],"parameters":{"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]},"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]}},"annotations":[]},"readAsBytes":{"name":"readAsBytes","qualifiedName":"dart-io.File.readAsBytes","comment":"<p>Read the entire file contents as a list of bytes. Returns a\n<code>Future&lt;List&lt;int&gt;&gt;</code> that completes with the list of bytes that\nis the contents of the file.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"parameters":{},"annotations":[]},"readAsBytesSync":{"name":"readAsBytesSync","qualifiedName":"dart-io.File.readAsBytesSync","comment":"<p>Synchronously read the entire file contents as a list of bytes.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{},"annotations":[]},"readAsString":{"name":"readAsString","qualifiedName":"dart-io.File.readAsString","comment":"<p>Read the entire file contents as a string using the given\n<a>dart-convert.Encoding</a>.</p>\n<p>Returns a <code>Future&lt;String&gt;</code> that completes with the string once\nthe file contents has been read.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]}},"annotations":[]},"readAsStringSync":{"name":"readAsStringSync","qualifiedName":"dart-io.File.readAsStringSync","comment":"<p>Synchronously read the entire file contents as a string using the\ngiven <a>dart-convert.Encoding</a>.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]}},"annotations":[]},"readAsLines":{"name":"readAsLines","qualifiedName":"dart-io.File.readAsLines","comment":"<p>Read the entire file contents as lines of text using the given\n<a>dart-convert.Encoding</a>.</p>\n<p>Returns a <code>Future&lt;List&lt;String&gt;&gt;</code> that completes with the lines\nonce the file contents has been read.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}]}],"parameters":{"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]}},"annotations":[]},"readAsLinesSync":{"name":"readAsLinesSync","qualifiedName":"dart-io.File.readAsLinesSync","comment":"<p>Synchronously read the entire file contents as lines of text\nusing the given <a>dart-convert.Encoding</a>.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]}},"annotations":[]},"writeAsBytes":{"name":"writeAsBytes","qualifiedName":"dart-io.File.writeAsBytes","comment":"<p>Write a list of bytes to a file.</p>\n<p>Opens the file, writes the list of bytes to it, and closes the file.\nReturns a <code>Future&lt;File&gt;</code> that completes with this <a>dart-io.File</a> object once\nthe entire operation has completed.</p>\n<p>By default <a>dart-io.File.writeAsBytes</a> creates the file for writing and truncates the\nfile if it already exists. In order to append the bytes to an existing\nfile, pass <a>dart-io.FileMode.APPEND</a> as the optional mode parameter.</p>\n<p>If the argument <a>dart-io.File.writeAsBytes.flush</a> is set to <code>true</code>, the data written will be\nflushed to the file system before the returned future completes.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.File","inner":[]}]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":"null","annotations":[]},"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]},"flush":{"name":"flush","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"writeAsBytesSync":{"name":"writeAsBytesSync","qualifiedName":"dart-io.File.writeAsBytesSync","comment":"<p>Synchronously write a list of bytes to a file.</p>\n<p>Opens the file, writes the list of bytes to it and closes the file.</p>\n<p>By default <a>dart-io.File.writeAsBytesSync</a> creates the file for writing and truncates\nthe file if it already exists. In order to append the bytes to an existing\nfile, pass <a>dart-io.FileMode.APPEND</a> as the optional mode parameter.</p>\n<p>If the <a>dart-io.File.writeAsBytesSync.flush</a> argument is set to <code>true</code> data written will be\nflushed to the file system before returning.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":"null","annotations":[]},"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]},"flush":{"name":"flush","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"writeAsString":{"name":"writeAsString","qualifiedName":"dart-io.File.writeAsString","comment":"<p>Write a string to a file.</p>\n<p>Opens the file, writes the string in the given encoding, and closes the\nfile. Returns a <code>Future&lt;File&gt;</code> that completes with this <a>dart-io.File</a> object\nonce the entire operation has completed.</p>\n<p>By default <a>dart-io.File.writeAsString</a> creates the file for writing and truncates the\nfile if it already exists. In order to append the bytes to an existing\nfile, pass <a>dart-io.FileMode.APPEND</a> as the optional mode parameter.</p>\n<p>If the argument <a>dart-io.File.writeAsString.flush</a> is set to <code>true</code>, the data written will be\nflushed to the file system before the returned future completes.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.File","inner":[]}]}],"parameters":{"contents":{"name":"contents","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]},"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]},"flush":{"name":"flush","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"writeAsStringSync":{"name":"writeAsStringSync","qualifiedName":"dart-io.File.writeAsStringSync","comment":"<p>Synchronously write a string to a file.</p>\n<p>Opens the file, writes the string in the given encoding, and closes the\nfile.</p>\n<p>By default <a>dart-io.File.writeAsStringSync</a> creates the file for writing and\ntruncates the file if it already exists. In order to append the bytes\nto an existing file, pass <a>dart-io.FileMode.APPEND</a> as the optional mode\nparameter.</p>\n<p>If the <a>dart-io.File.writeAsStringSync.flush</a> argument is set to <code>true</code> data written will be\nflushed to the file system before returning.</p>\n<p>Throws a <a>dart-io.FileSystemException</a> if the operation fails.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"contents":{"name":"contents","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"mode":{"name":"mode","optional":true,"named":true,"default":true,"type":[{"outer":"dart-io.FileMode","inner":[]}],"value":"ConstructedConstant(FileMode(\"_mode\"=Instance of 'IntConstant'))","annotations":[]},"encoding":{"name":"encoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(Utf8Codec(\"_allowMalformed\"=Instance of 'FalseConstant'))","annotations":[]},"flush":{"name":"flush","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-io.File.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.File.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.File.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"path":{"name":"path","qualifiedName":"dart-io.File.path","comment":"","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.path","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"isAbsolute":{"name":"isAbsolute","qualifiedName":"dart-io.File.isAbsolute","comment":"<p>Returns a <a>dart-core.bool</a> indicating whether this object's path is absolute.</p>\n<p>On Windows, a path is absolute if it starts with \\\\ or a drive letter\nbetween a and z (upper or lower case) followed by :\\ or :/.\nOn non-Windows, a path is absolute if it starts with /.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.isAbsolute","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"absolute":{"name":"absolute","qualifiedName":"dart-io.File.absolute","comment":"<p>Returns a <a>dart-io.FileSystemEntity</a> whose path is the absolute path to this.\nThe type of the returned instance is the type of this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.absolute","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{},"annotations":[]},"parent":{"name":"parent","qualifiedName":"dart-io.File.parent","comment":"<p>The directory containing this.  If this is a root\ndirectory, returns this.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.parent","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.File.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.File.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.File.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"dart-io.File.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.File.noSuchMethod","comment":"<p><a>dart-io.File.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.File.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.File.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.File.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"exists":{"name":"exists","qualifiedName":"dart-io.File.exists","comment":"<p>Checks whether the file system entity with this path exists. Returns\na <code>Future&lt;bool&gt;</code> that completes with the result.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.File.exists</a> on an instance of one\nof these subclasses checks whether the object exists in the file\nsystem object exists and is of the correct type (file, directory,\nor link).  To check whether a path points to an object on the\nfile system, regardless of the object's type, use the <a>dart-io.FileSystemEntity.type</a>\nstatic method.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.exists","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{},"annotations":[]},"existsSync":{"name":"existsSync","qualifiedName":"dart-io.File.existsSync","comment":"<p>Synchronously checks whether the file system entity with this path\nexists.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.File.existsSync</a> on an instance of\none of these subclasses checks whether the object exists in the\nfile system object exists and is of the correct type (file,\ndirectory, or link).  To check whether a path points to an object\non the file system, regardless of the object's type, use the\n<a>dart-io.FileSystemEntity.typeSync</a> static method.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.existsSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.File.rename","comment":"<p>Renames this file system entity. Returns a <code>Future&lt;FileSystemEntity&gt;</code>\nthat completes with a <a>dart-io.FileSystemEntity</a> instance for the renamed\nfile system entity.</p>\n<p>If <a>dart-io.File.rename.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.File.rename.newPath</a> identifies an existing entity of a different\ntype, the operation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.rename","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.File.renameSync","comment":"<p>Synchronously renames this file system entity. Returns a <a>dart-io.FileSystemEntity</a>\ninstance for the renamed entity.</p>\n<p>If <a>dart-io.File.renameSync.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.File.renameSync.newPath</a> identifies an existing entity of a different\ntype, the operation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.renameSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"resolveSymbolicLinks":{"name":"resolveSymbolicLinks","qualifiedName":"dart-io.File.resolveSymbolicLinks","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.\n<a>dart-io.File.resolveSymbolicLinks</a> returns a <code>Future&lt;String&gt;</code></p>\n<p><a>dart-io.File.resolveSymbolicLinks</a> uses the operating system's native filesystem api\nto resolve the path, using the realpath function on linux and\nMac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.File.resolveSymbolicLinks</a> completes the returned Future with an FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.File.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.resolveSymbolicLinks","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"resolveSymbolicLinksSync":{"name":"resolveSymbolicLinksSync","qualifiedName":"dart-io.File.resolveSymbolicLinksSync","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.</p>\n<p><a>dart-io.File.resolveSymbolicLinksSync</a> uses the operating system's native\nfilesystem api to resolve the path, using the realpath function\non linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.File.resolveSymbolicLinksSync</a> throws a FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.File.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.resolveSymbolicLinksSync","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"stat":{"name":"stat","qualifiedName":"dart-io.File.stat","comment":"<p>Calls the operating system's stat() function on the <a>dart-io.File.path</a> of this\n<a>dart-io.FileSystemEntity</a>.  Identical to <code>FileStat.stat(this.path)</code>.</p>\n<p>Returns a <code>Future&lt;FileStat&gt;</code> object containing the data returned by\nstat().</p>\n<p>If the call fails, completes the future with a <a>dart-io.FileStat</a> object\nwith .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.stat","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileStat","inner":[]}]}],"parameters":{},"annotations":[]},"statSync":{"name":"statSync","qualifiedName":"dart-io.File.statSync","comment":"<p>Synchronously calls the operating system's stat() function on the\n<a>dart-io.File.path</a> of this <a>dart-io.FileSystemEntity</a>.\nIdentical to <code>FileStat.statSync(this.path)</code>.</p>\n<p>Returns a <a>dart-io.FileStat</a> object containing the data returned by stat().</p>\n<p>If the call fails, returns a <a>dart-io.FileStat</a> object with .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.statSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileStat","inner":[]}],"parameters":{},"annotations":[]},"delete":{"name":"delete","qualifiedName":"dart-io.File.delete","comment":"<p>Deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.File.delete.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.File.delete.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.File.delete.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.File.delete</a> to be used to unconditionally delete any file\nsystem object.</p>\n<p>Returns a <code>Future&lt;FileSystemEntity&gt;</code> that completes with this\n<a>dart-io.FileSystemEntity</a> when the deletion is done. If the <a>dart-io.FileSystemEntity</a>\ncannot be deleted, the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.delete","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"deleteSync":{"name":"deleteSync","qualifiedName":"dart-io.File.deleteSync","comment":"<p>Synchronously deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.File.deleteSync.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.File.deleteSync.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.File.deleteSync.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.File.deleteSync</a> to be used to unconditionally delete any\nfile system object.</p>\n<p>Throws an exception if the <a>dart-io.FileSystemEntity</a> cannot be deleted.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.deleteSync","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"watch":{"name":"watch","qualifiedName":"dart-io.File.watch","comment":"<p>Start watching the <a>dart-io.FileSystemEntity</a> for changes.</p>\n<p>The implementation uses platform-dependent event-based APIs for receiving\nfile-system notifications, thus behavior depends on the platform.</p><ul><li>\n<p><code>Windows</code>: Uses <code>ReadDirectoryChangesW</code>. The implementation only\nsupports watching directories. Recursive watching is supported.</p></li><li>\n<p><code>Linux</code>: Uses <code>inotify</code>. The implementation supports watching both\nfiles and directories. Recursive watching is not supported.\nNote: When watching files directly, delete events might not happen\nas expected.</p></li><li>\n<p><code>Mac OS</code>: Uses <code>FSEvents</code>. The implementation supports watching both\nfiles and directories. Recursive watching is supported.</p></li></ul>\n<p>The system will start listening for events once the returned <a>dart-async.Stream</a> is\nbeing listened to, not when the call to <a>dart-io.File.watch</a> is issued.</p>\n<p>The returned value is an endless broadcast <a>dart-async.Stream</a>, that only stops when\none of the following happends:</p><ul><li>\n<p>The <a>dart-async.Stream</a> is canceled, e.g. by calling <code>cancel</code> on the\n <a>dart-async.StreamSubscription</a>.</p></li><li>The <a>dart-io.FileSystemEntity</a> being watches, is deleted.</li></ul>\n<p>Use <code>events</code> to specify what events to listen for. The constants in\n<a>dart-io.FileSystemEvent</a> can be or'ed together to mix events. Default is\n<a>dart-io.FileSystemEvent.ALL</a>.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.watch","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-io.FileSystemEvent","inner":[]}]}],"parameters":{"events":{"name":"events","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"15","annotations":[]},"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}