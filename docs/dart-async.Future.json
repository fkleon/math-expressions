{"name":"Future","qualifiedName":"dart-async.Future","comment":"<p>An object representing a delayed computation.</p>\n<p>A <a>dart-async.Future</a> is used to represent a potential value, or error,\nthat will be available at some time in the future.\nReceivers of a <a>dart-async.Future</a> can register callbacks\nthat handle the value or error once it is available.\nFor example:</p>\n<pre><code>Future&lt;int&gt; future = getFuture();\nfuture.then((value) =&gt; handleValue(value))\n      .catchError((error) =&gt; handleError(error));\n</code></pre>\n<p>A <a>dart-async.Future</a> can complete in two ways:\nwith a value (\"the future succeeds\")\nor with an error (\"the future fails\").\nUsers can install callbacks for each case.\nThe result of registering a pair of callbacks is a new Future (the\n\"successor\") which in turn is completed with the result of invoking the\ncorresponding callback.\nThe successor is completed with an error if the invoked callback throws.\nFor example:</p>\n<pre><code>Future&lt;int&gt; successor = future.then((int value) {\n    // Invoked when the future is completed with a value.\n    return 42;  // The successor is completed with the value 42.\n  },\n  onError: (e) {\n    // Invoked when the future is completed with an error.\n    if (canHandle(e)) {\n      return 499;  // The successor is completed with the value 499.\n    } else {\n      throw e;  // The successor is completed with the error e.\n    }\n  });\n</code></pre>\n<p>If a future does not have a successor when it completes with an error,\nit forwards the error message to the global error-handler.\nThis behavior makes sure that no error is silently dropped.\nHowever, it also means that error handlers should be installed early,\nso that they are present as soon as a future is completed with an error.\nThe following example demonstrates this potential bug:</p>\n<pre><code>var future = getFuture();\nnew Timer(new Duration(milliseconds: 5), () {\n  // The error-handler is not attached until 5 ms after the future has\n  // been received. If the future fails before that, the error is\n  // forwarded to the global error-handler, even though there is code\n  // (just below) to eventually handle the error.\n  future.then((value) { useValue(value); },\n              onError: (e) { handleError(e); });\n});\n</code></pre>\n<p>When registering callbacks, it's often more readable to register the two\ncallbacks separately, by first using <a>dart-async.Future.then</a> with one argument\n(the value handler) and using a second <a>dart-async.Future.catchError</a> for handling errors.\nEach of these will forward the result that they don't handle\nto their successors, and together they handle both value and error result.\nIt also has the additional benefit of the <a>dart-async.Future.catchError</a> handling errors in the\n<a>dart-async.Future.then</a> value callback too.\nUsing sequential handlers instead of parallel ones often leads to code that\nis easier to reason about.\nIt also makes asynchronous code very similar to synchronous code:</p>\n<pre><code>// Synchronous code.\ntry {\n  int value = foo();\n  return bar(value);\n} catch (e) {\n  return 499;\n}\n</code></pre>\n<p>Equivalent asynchronous code, based on futures:</p>\n<pre><code>Future&lt;int&gt; future = new Future(foo);  // Result of foo() as a future.\nfuture.then((int value) =&gt; bar(value))\n      .catchError((e) =&gt; 499);\n</code></pre>\n<p>Similar to the synchronous code, the error handler (registered with\n<a>dart-async.Future.catchError</a>) is handling any errors thrown by either <code>foo</code> or <code>bar</code>.\nIf the error-handler had been registered as the <code>onError</code> parameter of\nthe <code>then</code> call, it would not catch errors from the <code>bar</code> call.</p>\n<p>Futures can have more than one callback-pair registered. Each successor is\ntreated independently and is handled as if it was the only successor.</p>\n<p>A future may also fail to ever complete. In that case, no callbacks are\ncalled.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{},"constructors":{"":{"name":"","qualifiedName":"dart-async.Future.Future-","comment":"<p>Creates a future containing the result of calling <a>dart-async.Future.Future-.computation</a>\nasynchronously with <a>dart-async.Timer.run</a>.</p>\n<p>If the result of executing <a>dart-async.Future.Future-.computation</a> throws, the returned future is\ncompleted with the error.</p>\n<p>If the returned value is itself a <a>dart-async.Future</a>, completion of\nthe created future will wait until the returned future completes,\nand will then complete with the same result.</p>\n<p>If a non-future value is returned, the returned future is completed\nwith that value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"computation":{"name":"computation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"microtask":{"name":"microtask","qualifiedName":"dart-async.Future.Future-microtask","comment":"<p>Creates a future containing the result of calling <a>dart-async.Future.Future-microtask.computation</a>\nasynchronously with <a>dart-async.scheduleMicrotask</a>.</p>\n<p>If executing <a>dart-async.Future.Future-microtask.computation</a> throws,\nthe returned future is completed with the thrown error.</p>\n<p>If calling <a>dart-async.Future.Future-microtask.computation</a> returns a <a>dart-async.Future</a>, completion of\nthe created future will wait until the returned future completes,\nand will then complete with the same result.</p>\n<p>If calling <a>dart-async.Future.Future-microtask.computation</a> returns a non-future value,\nthe returned future is completed with that value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"computation":{"name":"computation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"sync":{"name":"sync","qualifiedName":"dart-async.Future.Future-sync","comment":"<p>Creates a future containing the result of immediately calling\n<a>dart-async.Future.Future-sync.computation</a>.</p>\n<p>If calling <a>dart-async.Future.Future-sync.computation</a> throws, the returned future is completed with the\nerror.</p>\n<p>If calling <a>dart-async.Future.Future-sync.computation</a> returns a <a>dart-async.Future</a>, completion of\nthe created future will wait until the returned future completes,\nand will then complete with the same result.</p>\n<p>If calling <a>dart-async.Future.Future-sync.computation</a> returns a non-future value,\nthe returned future is completed with that value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"computation":{"name":"computation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"value":{"name":"value","qualifiedName":"dart-async.Future.Future-value","comment":"<p>A future whose value is available in the next event-loop iteration.</p>\n<p>If <a>dart-async.Future.Future-value.value</a> is not a <a>dart-async.Future</a>, using this constructor is equivalent\nto <code>new Future&lt;T&gt;.sync(() =&gt; value)</code>.</p>\n<p>Use <a>dart-async.Completer</a> to create a Future and complete it later.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"value":{"name":"value","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"error":{"name":"error","qualifiedName":"dart-async.Future.Future-error","comment":"<p>A future that completes with an error in the next event-loop iteration.</p>\n<p>Use <a>dart-async.Completer</a> to create a Future and complete it later.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"error":{"name":"error","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":"null","annotations":[]},"stackTrace":{"name":"stackTrace","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.StackTrace","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"delayed":{"name":"delayed","qualifiedName":"dart-async.Future.Future-delayed","comment":"<p>Creates a future that completes after a delay.</p>\n<p>The future will be completed after the given <a>dart-async.Future.Future-delayed.duration</a> has passed with\nthe result of calling <a>dart-async.Future.Future-delayed.computation</a>. If the duration is 0 or less, it\ncompletes no sooner than in the next event-loop iteration.</p>\n<p>If <a>dart-async.Future.Future-delayed.computation</a> is omitted,\nit will be treated as if <a>dart-async.Future.Future-delayed.computation</a> was set to <code>() =&gt; null</code>,\nand the future will eventually complete with the <code>null</code> value.</p>\n<p>If calling <a>dart-async.Future.Future-delayed.computation</a> throws, the created future will complete with the\nerror.</p>\n<p>See also <a>dart-async.Completer</a> for a way to complete a future at a later\ntime that isn't a known fixed duration.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"duration":{"name":"duration","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Duration","inner":[]}],"value":"null","annotations":[]},"computation":{"name":"computation","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"wait":{"name":"wait","qualifiedName":"dart-async.Future.wait","comment":"<p>Wait for all the given futures to complete and collect their values.</p>\n<p>Returns a future which will complete once all the futures in a list are\ncomplete. If any of the futures in the list completes with an error,\nthe resulting future also completes with an error. Otherwise the value\nof the returned future will be a list of all the values that were produced.</p>\n<p>If <code>eagerError</code> is true, the future completes with an error immediately on\nthe first error from one of the futures. Otherwise all futures must\ncomplete before the returned future is completed (still with the first\nerror to occur, the remaining errors are silently dropped).</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.List","inner":[]}]}],"parameters":{"futures":{"name":"futures","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-async.Future","inner":[]}]}],"value":"null","annotations":[]},"eagerError":{"name":"eagerError","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"forEach":{"name":"forEach","qualifiedName":"dart-async.Future.forEach","comment":"<p>Perform an async operation for each element of the iterable, in turn.</p>\n<p>Runs <a>dart-async.Future.forEach.f</a> for each element in <a>dart-async.Future.forEach.input</a> in order, moving to the next element\nonly when the <a>dart-async.Future</a> returned by <a>dart-async.Future.forEach.f</a> completes. Returns a <a>dart-async.Future</a> that\ncompletes when all elements have been processed.</p>\n<p>The return values of all <a>dart-async.Future</a>s are discarded. Any errors will cause the\niteration to stop and will be piped through the returned <a>dart-async.Future</a>.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"input":{"name":"input","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":"null","annotations":[]},"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"then":{"name":"then","qualifiedName":"dart-async.Future.then","comment":"<p>Register callbacks to be called when this future completes.</p>\n<p>When this future completes with a value,\nthe <a>dart-async.Future.then.onValue</a> callback will be called with that value.\nIf this future is already completed, the callback will not be called\nimmediately, but will be scheduled in a later microtask.</p>\n<p>If <a>dart-async.Future.then.onError</a> is provided, and this future completes with an error,\nthe <code>onError</code> callback is called with that error its stack trace.\nThe <code>onError</code> callback must accept either one argument or two arguments.\nIf <code>onError</code> accepts two arguments,\nit is called with both the error and the stack trace,\notherwise it is called with just the error object.</p>\n<p>Returns a new <a>dart-async.Future</a>\nwhich is completed with the result of the call to <code>onValue</code>\n(if this future completes with a value)\nor to <code>onError</code> (if this future completes with an error).</p>\n<p>If the invoked callback throws,\nthe returned future is completed with the thrown error\nand a stack trace for the error.\nIn the case of <code>onError</code>,\nif the exception thrown is <code>identical</code> to the error argument to <code>onError</code>,\nthe throw is considered a rethrow,\nand the original stack trace is used instead.</p>\n<p>If the callback returns a <a>dart-async.Future</a>,\nthe future returned by <code>then</code> will be completed with\nthe same result of the future returned by the callback.</p>\n<p>If <a>dart-async.Future.then.onError</a> is not given, and this future completes with an error,\nthe error is forwarded directly to the returned future.</p>\n<p>In most cases, it is more readable to use <a>dart-async.Future.catchError</a> separately, possibly\nwith a <code>test</code> parameter, instead of handling both value and error in a\nsingle <a>dart-async.Future.then</a> call.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"onValue":{"name":"onValue","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"onError":{"name":"onError","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"catchError":{"name":"catchError","qualifiedName":"dart-async.Future.catchError","comment":"<p>Handles errors emitted by this <a>dart-async.Future</a>.</p>\n<p>This is the asynchronous equivalent of a \"catch\" block.</p>\n<p>Returns a new <a>dart-async.Future</a> that will be completed with either the result of\nthis future or the result of calling the <code>onError</code> callback.</p>\n<p>If this future completes with a value,\nthe returned future completes with the same value.</p>\n<p>If this future completes with an error,\nthen <a>dart-async.Future.catchError.test</a> is first called with the error value.</p>\n<p>If <code>test</code> returns false, the exception is not handled by this <code>catchError</code>,\nand the returned future completes with the same error and stack trace\nas this future.</p>\n<p>If <code>test</code> returns <code>true</code>,\n<a>dart-async.Future.catchError.onError</a> is called with the error and possibly stack trace,\nand the returned future is completed with the result of this call\nin exactly the same way as for <a>dart-async.Future.then</a>'s <code>onError</code>.</p>\n<p>If <code>test</code> is omitted, it defaults to a function that always returns true.\nThe <code>test</code> function should not throw, but if it does, it is handled as\nif the the <code>onError</code> function had thrown.</p>\n<p>Example:</p>\n<pre><code>foo\n  .catchError(..., test: (e) =&gt; e is ArgumentError)\n  .catchError(..., test: (e) =&gt; e is NoSuchMethodError)\n  .then((v) { ... });\n</code></pre>\n<p>This method is equivalent to:</p>\n<pre><code>Future catchError(onError(error),\n                  {bool test(error)}) {\n  this.then((v) =&gt; v,  // Forward the value.\n            // But handle errors, if the [test] succeeds.\n            onError: (e, stackTrace) {\n              if (test == null || test(e)) {\n                if (onError is ZoneBinaryCallback) {\n                  return onError(e, stackTrace);\n                }\n                return onError(e);\n              }\n              throw e;\n            });\n}\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"onError":{"name":"onError","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]},"test":{"name":"test","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"whenComplete":{"name":"whenComplete","qualifiedName":"dart-async.Future.whenComplete","comment":"<p>Register a function to be called when this future completes.</p>\n<p>The <a>dart-async.Future.whenComplete.action</a> function is called when this future completes, whether it\ndoes so with a value or with an error.</p>\n<p>This is the asynchronous equivalent of a \"finally\" block.</p>\n<p>The future returned by this call, <code>f</code>, will complete the same way\nas this future unless an error occurs in the <a>dart-async.Future.whenComplete.action</a> call, or in\na <a>dart-async.Future</a> returned by the <a>dart-async.Future.whenComplete.action</a> call. If the call to <a>dart-async.Future.whenComplete.action</a>\ndoes not return a future, its return value is ignored.</p>\n<p>If the call to <a>dart-async.Future.whenComplete.action</a> throws, then <code>f</code> is completed with the\nthrown error.</p>\n<p>If the call to <a>dart-async.Future.whenComplete.action</a> returns a <a>dart-async.Future</a>, <code>f2</code>, then completion of\n<code>f</code> is delayed until <code>f2</code> completes. If <code>f2</code> completes with\nan error, that will be the result of <code>f</code> too. The value of <code>f2</code> is always\nignored.</p>\n<p>This method is equivalent to:</p>\n<pre><code>Future&lt;T&gt; whenComplete(action()) {\n  this.then((v) {\n              var f2 = action();\n              if (f2 is Future) return f2.then((_) =&gt; v);\n              return v\n            },\n            onError: (e) {\n              var f2 = action();\n              if (f2 is Future) return f2.then((_) { throw e; });\n              throw e;\n            });\n}\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{"action":{"name":"action","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"asStream":{"name":"asStream","qualifiedName":"dart-async.Future.asStream","comment":"<p>Creates a <a>dart-async.Stream</a> that sends this' completion value, data or error, to\nits subscribers. The stream closes after the completion value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-async._Future.T","inner":[]}]}],"parameters":{},"annotations":[]},"timeout":{"name":"timeout","qualifiedName":"dart-async.Future.timeout","comment":"<p>Time-out the future computation after <a>dart-async.Future.timeout.timeLimit</a> has passed.</p>\n<p>Returns a new future that completes with the same value as this future,\nif this future completes in time.</p>\n<p>If this future does not complete before <code>timeLimit</code> has passed,\nthe <a>dart-async.Future.timeout.onTimeout</a> action is executed instead, and its result (whether it\nreturns or throws) is used as the result of the returned future.</p>\n<p>If <code>onTimeout</code> is omitted, a timeout will cause the returned future to\ncomplete with a <a>dart-async.TimeoutException</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"timeLimit":{"name":"timeLimit","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Duration","inner":[]}],"value":"null","annotations":[]},"onTimeout":{"name":"onTimeout","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-async.Future.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-async.Future.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-async.Future.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-async.Future.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-async.Future.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-async.Future.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"dart-async.Future.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-async.Future.noSuchMethod","comment":"<p><a>dart-async.Future.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-async.Future.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-async.Future.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-async.Future.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{"T":{"name":"T","type":"dart.core.Object"}}}