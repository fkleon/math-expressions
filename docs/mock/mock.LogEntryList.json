{"name":"LogEntryList","qualifiedName":"mock/mock.LogEntryList","comment":"<p>We do verification on a list of <a>mock/mock.LogEntry</a>s. To allow chaining\nof calls to verify, we encapsulate such a list in the <a>mock/mock.LogEntryList</a>\nclass.</p>","isAbstract":false,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{"filter":{"name":"filter","qualifiedName":"mock/mock.LogEntryList.filter","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"logs":{"name":"logs","qualifiedName":"mock/mock.LogEntryList.logs","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"mock/mock.LogEntry","inner":[]}]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{"first":{"name":"first","qualifiedName":"mock/mock.LogEntryList.first","comment":"<p>Get the first entry, or null if no entries.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]},"last":{"name":"last","qualifiedName":"mock/mock.LogEntryList.last","comment":"<p>Get the last entry, or null if no entries.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"mock/mock.LogEntryList.LogEntryList-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"filter":{"name":"filter","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"add":{"name":"add","qualifiedName":"mock/mock.LogEntryList.add","comment":"<p>Add a <a>mock/mock.LogEntry</a> to the log.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"entry":{"name":"entry","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntry","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"getMatches":{"name":"getMatches","qualifiedName":"mock/mock.LogEntryList.getMatches","comment":"<p>Create a new <a>mock/mock.LogEntryList</a> consisting of <a>mock/mock.LogEntry</a>s from\nthis list that match the specified <a>mock/mock.LogEntryList.getMatches.mockNameFilter</a> and <a>mock/mock.LogEntryList.getMatches.logFilter</a>.\n<a>mock/mock.LogEntryList.getMatches.mockNameFilter</a> can be null, a <a>dart-core.String</a>, a predicate <a>dart-core.Function</a>,\nor a <a>mock/mock.Matcher</a>. If <a>mock/mock.LogEntryList.getMatches.mockNameFilter</a> is null, this is the same as\n<a>mock/matcher.anything</a>.\nIf <a>mock/mock.LogEntryList.getMatches.logFilter</a> is null, all entries in the log will be returned.\nOtherwise <a>mock/mock.LogEntryList.getMatches.logFilter</a> should be a <a>mock/mock.CallMatcher</a> or  predicate function\nthat takes a <a>mock/mock.LogEntry</a> and returns a bool.\nIf <a>mock/mock.LogEntryList.getMatches.destructive</a> is true, the log entries are removed from the\noriginal list.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"mockNameFilter":{"name":"mockNameFilter","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"logFilter":{"name":"logFilter","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"actionMatcher":{"name":"actionMatcher","optional":true,"named":false,"default":false,"type":[{"outer":"mock/mock.Matcher","inner":[]}],"value":"null","annotations":[]},"destructive":{"name":"destructive","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"verify":{"name":"verify","qualifiedName":"mock/mock.LogEntryList.verify","comment":"<p>Apply a unit test <a>mock/mock.Matcher</a> to the <a>mock/mock.LogEntryList</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.Matcher","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"stepwiseValidate":{"name":"stepwiseValidate","qualifiedName":"mock/mock.LogEntryList.stepwiseValidate","comment":"<p>Iterate through the list and call the <a>mock/mock.LogEntryList.stepwiseValidate.validator</a> function with the\nlog <a>dart-core.List</a> and position. The <a>mock/mock.LogEntryList.stepwiseValidate.validator</a> should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported. <a>mock/mock.LogEntryList.stepwiseValidate.reason</a> can be used to provide a\nmore descriptive failure message. If a failure occurred false will be\nreturned (unless the failure handler itself threw an exception);\notherwise true is returned.\nThe use case here is to perform more complex validations; for example\nwe may want to assert that the return value from some function is\nlater used as a parameter to a following function. If we filter the logs\nto include just these two functions we can write a simple validator to\ndo this check.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"validator":{"name":"validator","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.StepValidator","inner":[]}],"value":"null","annotations":[]},"reason":{"name":"reason","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"StringConstant(\"\")","annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"mock/mock.LogEntryList.toString","comment":"<p>Turn the logs into human-readable text. If <a>mock/mock.LogEntryList.toString.baseTime</a> is specified\nthen each entry is prefixed with the offset from that time in\nmilliseconds; otherwise the time of day is used.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"baseTime":{"name":"baseTime","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.DateTime","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"findLogEntry":{"name":"findLogEntry","qualifiedName":"mock/mock.LogEntryList.findLogEntry","comment":"<p>Find the first log entry that satisfies <a>mock/mock.LogEntryList.findLogEntry.logFilter</a> and\n return its position. A search <a>mock/mock.LogEntryList.findLogEntry.start</a> position can be provided\n to allow for repeated searches. <a>mock/mock.LogEntryList.findLogEntry.logFilter</a> can be a <a>mock/mock.CallMatcher</a>,\n or a predicate function that takes a <a>mock/mock.LogEntry</a> argument and returns\n a bool. If <a>mock/mock.LogEntryList.findLogEntry.logFilter</a> is null, it will match any <a>mock/mock.LogEntry</a>.\n If no entry is found, then <a>mock/mock.LogEntryList.findLogEntry.failureReturnValue</a> is returned.\n After each check the position is updated by <a>mock/mock.LogEntryList.findLogEntry.skip</a>, so using\n <a>mock/mock.LogEntryList.findLogEntry.skip</a> of -1 allows backward searches, using a <a>mock/mock.LogEntryList.findLogEntry.skip</a> of 2 can\n be used to check pairs of adjacent entries, and so on.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"logFilter":{"name":"logFilter","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"failureReturnValue":{"name":"failureReturnValue","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"-1","annotations":[]},"skip":{"name":"skip","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"1","annotations":[]}},"annotations":[]},"after":{"name":"after","qualifiedName":"mock/mock.LogEntryList.after","comment":"<p>Returns log events that happened after <a>mock/mock.LogEntryList.after.when</a>. If <a>mock/mock.LogEntryList.after.inPlace</a>\nis true, then it returns this LogEntryList after removing\nthe entries that happened up to <a>mock/mock.LogEntryList.after.when</a>; otherwise a new\nlist is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"when":{"name":"when","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.DateTime","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"from":{"name":"from","qualifiedName":"mock/mock.LogEntryList.from","comment":"<p>Returns log events that happened from <a>mock/mock.LogEntryList.from.when</a> onwards. If\n<a>mock/mock.LogEntryList.from.inPlace</a> is true, then it returns this LogEntryList after\nremoving the entries that happened before <a>mock/mock.LogEntryList.from.when</a>; otherwise\na new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"when":{"name":"when","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.DateTime","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"until":{"name":"until","qualifiedName":"mock/mock.LogEntryList.until","comment":"<p>Returns log events that happened until <a>mock/mock.LogEntryList.until.when</a>. If <a>mock/mock.LogEntryList.until.inPlace</a>\nis true, then it returns this LogEntryList after removing\nthe entries that happened after <a>mock/mock.LogEntryList.until.when</a>; otherwise a new\nlist is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"when":{"name":"when","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.DateTime","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"before":{"name":"before","qualifiedName":"mock/mock.LogEntryList.before","comment":"<p>Returns log events that happened before <a>mock/mock.LogEntryList.before.when</a>. If <a>mock/mock.LogEntryList.before.inPlace</a>\nis true, then it returns this LogEntryList after removing\nthe entries that happened from <a>mock/mock.LogEntryList.before.when</a> onwards; otherwise a new\nlist is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"when":{"name":"when","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.DateTime","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"afterEntry":{"name":"afterEntry","qualifiedName":"mock/mock.LogEntryList.afterEntry","comment":"<p>Returns log events that happened after <a>mock/mock.LogEntryList.afterEntry.logEntry</a>'s time.\nIf <a>mock/mock.LogEntryList.afterEntry.inPlace</a> is true, then it returns this LogEntryList after\nremoving the entries that happened up to when; otherwise a new\nlist is created. If <a>mock/mock.LogEntryList.afterEntry.logEntry</a> is null the current time is used.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"logEntry":{"name":"logEntry","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntry","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"fromEntry":{"name":"fromEntry","qualifiedName":"mock/mock.LogEntryList.fromEntry","comment":"<p>Returns log events that happened from <a>mock/mock.LogEntryList.fromEntry.logEntry</a>'s time onwards.\nIf <a>mock/mock.LogEntryList.fromEntry.inPlace</a> is true, then it returns this LogEntryList after\nremoving the entries that happened before when; otherwise\na new list is created. If <a>mock/mock.LogEntryList.fromEntry.logEntry</a> is null the current time is used.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"logEntry":{"name":"logEntry","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntry","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"untilEntry":{"name":"untilEntry","qualifiedName":"mock/mock.LogEntryList.untilEntry","comment":"<p>Returns log events that happened until <a>mock/mock.LogEntryList.untilEntry.logEntry</a>'s time. If\n<a>mock/mock.LogEntryList.untilEntry.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened after when; otherwise a new\nlist is created. If <a>mock/mock.LogEntryList.untilEntry.logEntry</a> is null the epoch time is used.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"logEntry":{"name":"logEntry","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntry","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"beforeEntry":{"name":"beforeEntry","qualifiedName":"mock/mock.LogEntryList.beforeEntry","comment":"<p>Returns log events that happened before <a>mock/mock.LogEntryList.beforeEntry.logEntry</a>'s time. If\n<a>mock/mock.LogEntryList.beforeEntry.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened from when onwards; otherwise a new\nlist is created. If <a>mock/mock.LogEntryList.beforeEntry.logEntry</a> is null the epoch time is used.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"logEntry":{"name":"logEntry","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntry","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"afterFirst":{"name":"afterFirst","qualifiedName":"mock/mock.LogEntryList.afterFirst","comment":"<p>Returns log events that happened after the first event in <a>mock/mock.LogEntryList.afterFirst.segment</a>.\nIf <a>mock/mock.LogEntryList.afterFirst.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"afterLast":{"name":"afterLast","qualifiedName":"mock/mock.LogEntryList.afterLast","comment":"<p>Returns log events that happened after the last event in <a>mock/mock.LogEntryList.afterLast.segment</a>.\nIf <a>mock/mock.LogEntryList.afterLast.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"fromFirst":{"name":"fromFirst","qualifiedName":"mock/mock.LogEntryList.fromFirst","comment":"<p>Returns log events that happened from the time of the first event in\n<a>mock/mock.LogEntryList.fromFirst.segment</a> onwards. If <a>mock/mock.LogEntryList.fromFirst.inPlace</a> is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"fromLast":{"name":"fromLast","qualifiedName":"mock/mock.LogEntryList.fromLast","comment":"<p>Returns log events that happened from the time of the last event in\n<a>mock/mock.LogEntryList.fromLast.segment</a> onwards. If <a>mock/mock.LogEntryList.fromLast.inPlace</a> is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"untilFirst":{"name":"untilFirst","qualifiedName":"mock/mock.LogEntryList.untilFirst","comment":"<p>Returns log events that happened until the first event in <a>mock/mock.LogEntryList.untilFirst.segment</a>.\nIf <a>mock/mock.LogEntryList.untilFirst.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"untilLast":{"name":"untilLast","qualifiedName":"mock/mock.LogEntryList.untilLast","comment":"<p>Returns log events that happened until the last event in <a>mock/mock.LogEntryList.untilLast.segment</a>.\nIf <a>mock/mock.LogEntryList.untilLast.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"beforeFirst":{"name":"beforeFirst","qualifiedName":"mock/mock.LogEntryList.beforeFirst","comment":"<p>Returns log events that happened before the first event in <a>mock/mock.LogEntryList.beforeFirst.segment</a>.\nIf <a>mock/mock.LogEntryList.beforeFirst.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"beforeLast":{"name":"beforeLast","qualifiedName":"mock/mock.LogEntryList.beforeLast","comment":"<p>Returns log events that happened before the last event in <a>mock/mock.LogEntryList.beforeLast.segment</a>.\nIf <a>mock/mock.LogEntryList.beforeLast.inPlace</a> is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"segment":{"name":"segment","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"inPlace":{"name":"inPlace","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"preceding":{"name":"preceding","qualifiedName":"mock/mock.LogEntryList.preceding","comment":"<p>Iterate through the LogEntryList looking for matches to the entries\nin <a>mock/mock.LogEntryList.preceding.keys</a>; for each match found the closest <a>mock/mock.LogEntryList.preceding.distance</a> prior log entries\nthat match mocknameFilter and <a>mock/mock.LogEntryList.preceding.logFilter</a> will be included in the result.\nIf <a>mock/mock.LogEntryList.preceding.includeKeys</a> is true then the entries in <a>mock/mock.LogEntryList.preceding.keys</a> that resulted in\nentries in the output list are themselves included in the output list. If\n<a>mock/mock.LogEntryList.preceding.distance</a> is zero then all matches are included.</p>\n<p>The idea here is that you could find log entries that are related to\nother logs entries in some temporal sense. For example, say we have a\nmethod commit() that returns -1 on failure. Before commit() gets called\nthe value being committed is created by process(). We may want to find\nthe calls to process() that preceded calls to commit() that failed.\nWe could do this with:</p>\n<pre><code> print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n     logFilter: callsTo('process')).toString());\n</code></pre>\n<p>We might want to include the details of the failing calls to commit()\nto see what parameters were passed in, in which case we would set\n<a>mock/mock.LogEntryList.preceding.includeKeys</a>.</p>\n<p>As another simple example, say we wanted to know the three method\ncalls that immediately preceded each failing call to commit():</p>\n<pre><code>print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n    distance: 3).toString());\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"keys":{"name":"keys","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"mockNameFilter":{"name":"mockNameFilter","optional":true,"named":true,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"logFilter":{"name":"logFilter","optional":true,"named":true,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"distance":{"name":"distance","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"includeKeys":{"name":"includeKeys","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"following":{"name":"following","qualifiedName":"mock/mock.LogEntryList.following","comment":"<p>Iterate through the LogEntryList looking for matches to the entries\nin <a>mock/mock.LogEntryList.following.keys</a>; for each match found the closest <a>mock/mock.LogEntryList.following.distance</a> subsequent log\nentries that match mocknameFilter and <a>mock/mock.LogEntryList.following.logFilter</a> will be included in\nthe result. If <a>mock/mock.LogEntryList.following.includeKeys</a> is true then the entries in <a>mock/mock.LogEntryList.following.keys</a> that\nresulted in entries in the output list are themselves included in the\noutput list. If <a>mock/mock.LogEntryList.following.distance</a> is zero then all matches are included.\nSee <a>mock/mock.LogEntryList.preceding</a> for a usage example.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"mock/mock.LogEntryList","inner":[]}],"parameters":{"keys":{"name":"keys","optional":false,"named":false,"default":false,"type":[{"outer":"mock/mock.LogEntryList","inner":[]}],"value":"null","annotations":[]},"mockNameFilter":{"name":"mockNameFilter","optional":true,"named":true,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"logFilter":{"name":"logFilter","optional":true,"named":true,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"distance":{"name":"distance","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"includeKeys":{"name":"includeKeys","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"mock/mock.LogEntryList.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>mock/mock.LogEntryList.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"mock/mock.LogEntryList.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"mock/mock.LogEntryList.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>mock/mock.LogEntryList.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>mock/mock.LogEntryList.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"mock/mock.LogEntryList.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"mock/mock.LogEntryList.noSuchMethod","comment":"<p><a>mock/mock.LogEntryList.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>mock/mock.LogEntryList.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>mock/mock.LogEntryList.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>mock/mock.LogEntryList.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}